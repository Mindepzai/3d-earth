<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng H·ªá M·∫∑t Tr·ªùi 3D - Phi√™n b·∫£n T·ªëi ∆∞u</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Th∆∞ vi·ªán Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-Processing dependencies for Bloom Effect (C·∫ßn cho M·∫∑t Tr·ªùi t·ªèa s√°ng) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/ConvolutionShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <style>
        /* T·ªëi ∆∞u h√≥a CSS cho di ƒë·ªông v√† m√°y t√≠nh */
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #0d1117;
            font-family: 'Inter', sans-serif;
            color: white;
            touch-action: none; /* NgƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
        }
        canvas {
            display: block;
        }
        
        #controls, #info-panel {
            position: absolute;
            padding: 0.75rem;
            background: rgba(17, 24, 39, 0.85);
            border-radius: 12px;
            z-index: 100;
            user-select: none;
            border: 1px solid rgba(55, 65, 81, 0.5);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
            max-height: 90vh; /* Gi·ªõi h·∫°n chi·ªÅu cao tr√™n m·ªçi thi·∫øt b·ªã */
            overflow-y: auto;
            transition: all 0.3s ease;
        }

        #controls {
            top: 1rem;
            left: 1rem;
            width: 250px;
            max-width: 90vw;
        }

        #info-panel {
            top: 1rem;
            right: 1rem;
            width: 300px;
            max-width: 90vw;
            display: none;
        }
        
        .btn {
            padding: 0.6rem 0.75rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s, transform 0.1s;
            line-height: 1; 
            font-size: 0.95rem;
        }
        .btn:active {
            transform: scale(0.98);
        }
        
        /* T√πy ch·ªânh thanh tr∆∞·ª£t */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #10b981;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
        }
        
        #planet-list {
            max-height: 300px;
            overflow-y: auto;
            /* Th√™m scrollbar style cho ƒë·∫πp h∆°n */
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #111827; 
        }

        #planet-list::-webkit-scrollbar {
            width: 8px;
        }
        #planet-list::-webkit-scrollbar-thumb {
            background-color: #4b5563;
            border-radius: 4px;
        }
        #planet-list::-webkit-scrollbar-track {
            background: #111827;
        }

        .planet-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.15s;
            font-size: 0.875rem;
        }
        .planet-item:hover {
            background-color: rgba(55, 65, 81, 0.5);
        }
        .planet-item.active {
            background-color: #3b82f6;
            font-weight: bold;
        }
        
        #llm-loading, #llm-response {
            font-style: italic;
        }
    </style>
</head>
<body>
    <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn (T·ªëc ƒë·ªô v√† Danh s√°ch) -->
    <div id="controls">
        <h2 class="text-lg font-bold text-blue-400 mb-3 border-b border-gray-700 pb-1">ƒêi·ªÅu khi·ªÉn M√¥ ph·ªèng</h2>
        
        <!-- Thanh ƒëi·ªÅu khi·ªÉn t·ªëc ƒë·ªô -->
        <div class="control-group mb-4">
            <label for="speedSlider" class="text-sm font-medium text-gray-300">T·ªëc ƒë·ªô M√¥ ph·ªèng: <span id="currentSpeed">1.0</span>x</label>
            <input type="range" id="speedSlider" min="0.1" max="5.0" step="0.1" value="1.0">
        </div>
        
        <!-- Danh s√°ch ch·ªçn h√†nh tinh -->
        <div class="control-group">
            <label class="text-sm font-medium text-gray-300 mb-2 block">T·∫≠p trung Camera</label>
            <div id="planet-list" class="bg-gray-800/70 p-1 rounded-lg">
                <!-- Danh s√°ch h√†nh tinh ƒë∆∞·ª£c ch√®n b·∫±ng JS -->
            </div>
        </div>
    </div>

    <!-- B·∫£ng th√¥ng tin H√†nh tinh -->
    <div id="info-panel">
        <h2 id="planet-name-title" class="text-xl font-bold mb-3 border-b border-gray-600 pb-2 text-yellow-300">Th√¥ng tin H√†nh tinh</h2>
        <div id="planet-details" class="text-sm space-y-2">
            <p class="info-detail">T√™n: <strong id="info-name"></strong></p>
            <p class="info-detail">K√≠ch th∆∞·ªõc (Rel.): <strong id="info-size"></strong></p>
            <p class="info-detail">B√°n k√≠nh Qu·ªπ ƒë·∫°o (Rel.): <strong id="info-orbit"></strong></p>
            <p class="info-detail">Kho·∫£ng c√°ch ƒë·∫øn MT (T·ª©c th·ªùi): <strong id="info-distance" class="text-green-400"></strong></p>
            <p class="info-detail">T·ªëc ƒë·ªô Qu·ªπ ƒë·∫°o: <strong id="info-speed"></strong></p>
        </div>

        <button id="get-llm-info" class="btn bg-indigo-600 hover:bg-indigo-700 text-white w-full mt-4">
            T√¨m hi·ªÉu th√™m v·ªÅ H√†nh tinh n√†y
        </button>

        <p id="llm-loading" class="mt-3 text-center text-sm">ƒêang t·∫£i th√¥ng tin t·ª´ Gemini/Google Search...</p>
        <div id="llm-response" class="hidden mt-3 p-3 rounded-lg bg-gray-700/60 text-sm"></div>
        <p id="llm-sources" class="text-xs text-gray-400 mt-2"></p>
    </div>
    
    <!-- Overlay H∆∞·ªõng d·∫´n -->
    <div id="help-overlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[200] transition-opacity duration-500">
        <div class="bg-gray-900 p-6 rounded-xl shadow-2xl max-w-sm mx-4 border border-blue-700">
            <h3 class="text-2xl font-extrabold text-blue-400 mb-4">Kh√°m ph√° H·ªá M·∫∑t Tr·ªùi ü™ê</h3>
            <ul class="text-sm space-y-3 text-gray-300">
                <li><strong class="text-white">Di chuy·ªÉn/Quay:</strong> Gi·ªØ chu·ªôt tr√°i (PC) ho·∫∑c ch·∫°m v√† k√©o (Mobile) ƒë·ªÉ xoay camera.</li>
                <li><strong class="text-white">Zoom:</strong> Cu·ªôn chu·ªôt (PC) ho·∫∑c d√πng hai ng√≥n tay ch·ª•m/t√°ch (Mobile).</li>
                <li><strong class="text-white">T·∫≠p trung:</strong> Nh·∫•n v√†o t√™n h√†nh tinh trong menu ho·∫∑c nh·∫•n tr·ª±c ti·∫øp v√†o h√†nh tinh.</li>
                <li><strong class="text-red-400">Ch·∫•m ƒë·ªè:</strong> Bi·ªÉu th·ªã v·ªã tr√≠ c·ªßa b·∫°n tr√™n Tr√°i ƒê·∫•t (ch·ªâ hi·ªán khi zoom g·∫ßn).</li>
            </ul>
            <button id="close-help" class="btn bg-blue-600 hover:bg-blue-700 text-white w-full mt-5">
                B·∫Øt ƒë·∫ßu kh√°m ph√°
            </button>
        </div>
    </div>


    <script>
        // === KHAI B√ÅO BI·∫æN TO√ÄN C·ª§C ===
        let scene = null;
        let camera = null;
        let renderer = null;
        let composer = null; 
        let clock = null;
        let solarSystemObjects = []; 
        let asteroids = null; 
        let moon = null;
        let earthClouds = null;
        let globalSpeedMultiplier = 1.0; 
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRadius = 1300; 
        let cameraAngle = { horizontal: 0, vertical: 0.4 }; 
        let focusTarget = new THREE.Vector3(0, 0, 0); 
        let currentFocusObject = null; 
        let initialPinchDistance = 0; 
        
        let focusIndicator = null; // V√≤ng s√°ng bao quanh h√†nh tinh ƒëang focus
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const INITIAL_SPEED_FACTOR = 0.5;

        // T·ªça ƒë·ªô ng∆∞·ªùi tr√™n Tr√°i ƒê·∫•t (ƒê·∫°i di·ªán cho H√† N·ªôi, Vi·ªát Nam - Latitude: 21.0285, Longitude: 105.8542)
        const HANOI_LATITUDE = 21.0285;
        const HANOI_LONGITUDE = 105.8542;
        let earth = null;
        let earthAnnotation = null; 
        const ANNOTATION_DISTANCE_THRESHOLD = 50; // Camera radius ƒë·ªÉ hi·ªÉn th·ªã ch·∫•m ƒë·ªè

        // D·ªØ li·ªáu H√†nh tinh (ƒê√£ ch·ªânh s·ª≠a th√¥ng s·ªë ƒë·ªÉ m√¥ ph·ªèng t·ªët h∆°n)
        const PLANET_DATA = [
            { name: 'Sun', size: 15, color: 0xffffff, emissive: 0xfdd45c, orbitRadius: 0, orbitSpeed: 0 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 0 }, 
            { name: 'Mercury', size: 1.0, color: 0x808080, orbitRadius: 30, orbitSpeed: 1.5 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.1 * INITIAL_SPEED_FACTOR, inclination: 7 * (Math.PI / 180) },
            { name: 'Venus', size: 2.5, color: 0xd2b48c, orbitRadius: 55, orbitSpeed: 1.0 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 3.4 * (Math.PI / 180) },
            { name: 'Earth', size: 3, color: 0x0088ff, orbitRadius: 90, orbitSpeed: 0.5 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.5 * INITIAL_SPEED_FACTOR, hasMoon: true, inclination: 0.0 * (Math.PI / 180) }, 
            { name: 'Mars', size: 1.5, color: 0xa0522d, orbitRadius: 130, orbitSpeed: 0.4 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.8 * INITIAL_SPEED_FACTOR, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Jupiter', size: 8, color: 0xd3a373, orbitRadius: 250, orbitSpeed: 0.2 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 1.5 * INITIAL_SPEED_FACTOR, inclination: 1.3 * (Math.PI / 180) },
            { name: 'Saturn', size: 6, color: 0xf5deb3, orbitRadius: 400, orbitSpeed: 0.15 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 1.2 * INITIAL_SPEED_FACTOR, hasRings: true, inclination: 2.5 * (Math.PI / 180), ringColor: 0x776655, axialTilt: 26.7 * (Math.PI / 180) }, 
            { name: 'Uranus', size: 4, color: 0xafdfe4, orbitRadius: 650, orbitSpeed: 0.1 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.8 * INITIAL_SPEED_FACTOR, hasRings: true, inclination: 0.77 * (Math.PI / 180), ringColor: 0xeeeeff, axialTilt: 98 * (Math.PI / 180) },
            { name: 'Neptune', size: 4, color: 0x00008b, orbitRadius: 900, orbitSpeed: 0.07 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.7 * INITIAL_SPEED_FACTOR, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Pluto', size: 0.5, color: 0xcccccc, orbitRadius: 1150, orbitSpeed: 0.03 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 17 * (Math.PI / 180) },
        ];
        
        // === C√ÅC H√ÄM X·ª¨ L√ù LLM (GENERATIVE API) ===

        function createGeminiPayload(query, systemPrompt = "") {
            const contents = [{ parts: [{ text: query }] }];
            const payload = {
                contents: contents,
                tools: [{ "google_search": {} }],
            };
            
            if (systemPrompt) {
                payload.systemInstruction = { parts: [{ text: systemPrompt }] };
            }

            return payload;
        }

        async function fetchPlanetInfo(planetName) {
            const loading = document.getElementById('llm-loading');
            const responseDiv = document.getElementById('llm-response');
            const sourcesDiv = document.getElementById('llm-sources');
            const button = document.getElementById('get-llm-info');

            loading.style.display = 'block';
            responseDiv.style.display = 'none';
            responseDiv.innerHTML = '';
            sourcesDiv.innerHTML = '';
            button.disabled = true;

            const systemPrompt = "B·∫°n l√† m·ªôt nh√† khoa h·ªçc v≈© tr·ª•, t√≥m t·∫Øt th√¥ng tin quan tr·ªçng v·ªÅ h√†nh tinh n√†y. Vi·∫øt m·ªôt ƒëo·∫°n vƒÉn ng·∫Øn g·ªçn, th√¢n thi·ªán, b·∫±ng ti·∫øng Vi·ªát, t·∫≠p trung v√†o c√°c ƒë·∫∑c ƒëi·ªÉm ƒë·ªôc ƒë√°o v√† th√¥ng tin th√∫ v·ªã nh·∫•t. Kh√¥ng s·ª≠ d·ª•ng markdown, ti√™u ƒë·ªÅ, ho·∫∑c k√Ω t·ª± ƒë·∫∑c bi·ªát.";
            const userQuery = `T√¨m th√¥ng tin chi ti·∫øt v·ªÅ H√†nh tinh ${planetName} (v√≠ d·ª•: nhi·ªát ƒë·ªô, th√†nh ph·∫ßn, ƒë·∫∑c ƒëi·ªÉm n·ªïi b·∫≠t) v√† t√≥m t·∫Øt.`;
            
            const apiKey = "" 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = createGeminiPayload(userQuery, systemPrompt);
            
            let maxRetries = 3;
            let delay = 1000;

            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (response.status === 429 && i < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, delay));
                        delay *= 2; 
                        continue;
                    }
                    
                    if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);

                    const result = await response.json();
                    const candidate = result.candidates?.[0];

                    if (candidate && candidate.content?.parts?.[0]?.text) {
                        const text = candidate.content.parts[0].text;
                        responseDiv.innerHTML = text;
                        responseDiv.style.display = 'block';

                        let sources = [];
                        const groundingMetadata = candidate.groundingMetadata;
                        if (groundingMetadata && groundingMetadata.groundingAttributions) {
                            sources = groundingMetadata.groundingAttributions
                                .map(attr => attr.web?.title)
                                .filter(title => title); 
                            
                            if (sources.length > 0) {
                                sourcesDiv.innerHTML = 'Ngu·ªìn: ' + sources.join(', ');
                            }
                        }
                    } else {
                         responseDiv.innerHTML = 'Kh√¥ng t√¨m th·∫•y th√¥ng tin chi ti·∫øt. Vui l√≤ng th·ª≠ l·∫°i.';
                         responseDiv.style.display = 'block';
                    }
                    
                    break; 

                } catch (error) {
                    console.error("L·ªói khi g·ªçi API Gemini:", error);
                    if (i === maxRetries - 1) {
                         responseDiv.innerHTML = 'L·ªói k·∫øt n·ªëi. Kh√¥ng th·ªÉ t√¨m th·∫•y th√¥ng tin.';
                         responseDiv.style.display = 'block';
                    }
                } finally {
                    loading.style.display = 'none';
                    button.disabled = false;
                }
            }
        }


        // === C√ÅC H√ÄM X·ª¨ L√ù 3D & UI ===

        /**
         * Th√™m ho·∫∑c c·∫≠p nh·∫≠t v√≤ng s√°ng focus xung quanh h√†nh tinh
         */
        function updateFocusIndicator() {
            // X√≥a indicator c≈© kh·ªèi h√†nh tinh c≈© (n·∫øu c√≥)
            if (focusIndicator) {
                focusIndicator.parent.remove(focusIndicator);
                focusIndicator.geometry.dispose();
                focusIndicator.material.dispose();
                focusIndicator = null;
            }

            if (currentFocusObject && currentFocusObject.userData.name !== 'Sun') {
                const size = currentFocusObject.userData.size;
                
                // T·∫°o m·ªôt v√≤ng s√°ng m·ªù quanh h√†nh tinh ƒëang focus
                const indicatorGeometry = new THREE.RingGeometry(size * 1.5, size * 1.6, 64);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffa500, // M√†u cam/v√†ng
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.35,
                    depthWrite: false, // Gi√∫p n√≥ lu√¥n hi·ªÉn th·ªã
                    blending: THREE.AdditiveBlending 
                });

                focusIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                focusIndicator.rotation.x = Math.PI / 2; // L√†m ph·∫≥ng
                focusIndicator.name = "FocusIndicator";

                currentFocusObject.add(focusIndicator);
            }
        }

        /**
         * C·∫≠p nh·∫≠t th√¥ng tin tr√™n b·∫£ng Info Panel
         */
        function updateInfoPanel(data) {
            const panel = document.getElementById('info-panel');
            const nameTitle = document.getElementById('planet-name-title');
            const infoName = document.getElementById('info-name');
            const infoSize = document.getElementById('info-size');
            const infoOrbit = document.getElementById('info-orbit');
            const infoSpeed = document.getElementById('info-speed');
            const infoDistance = document.getElementById('info-distance'); // NEW
            const getInfoButton = document.getElementById('get-llm-info');
            
            // X√≥a th√¥ng tin LLM c≈©
            document.getElementById('llm-response').innerHTML = '';
            document.getElementById('llm-response').style.display = 'none';
            document.getElementById('llm-sources').innerHTML = '';
            document.getElementById('llm-loading').style.display = 'none';

            if (!data) {
                panel.style.display = 'none';
                return;
            }

            panel.style.display = 'block';
            nameTitle.textContent = data.name;
            infoName.textContent = data.name;
            infoSize.textContent = `${data.size.toFixed(1)} ƒë∆°n v·ªã`;
            infoOrbit.textContent = `${data.orbitRadius.toFixed(1)} AU (m√¥ ph·ªèng)`;
            infoSpeed.textContent = `${(data.orbitSpeed / INITIAL_SPEED_FACTOR).toFixed(2)} ƒë∆°n v·ªã/s`;
            
            if (data.name === 'Sun') {
                 infoDistance.textContent = '0.00 AU';
                 getInfoButton.textContent = 'T√¨m hi·ªÉu th√™m v·ªÅ M·∫∑t Tr·ªùi';
                 getInfoButton.onclick = () => fetchPlanetInfo('M·∫∑t Tr·ªùi');
            } else {
                 infoDistance.textContent = 'ƒêang t√≠nh...';
                 getInfoButton.textContent = `T√¨m hi·ªÉu th√™m v·ªÅ ${data.name}`;
                 getInfoButton.onclick = () => fetchPlanetInfo(data.name);
            }
        }

        /**
         * Thi·∫øt l·∫≠p camera t·∫≠p trung v√†o m·ªôt ƒë·ªëi t∆∞·ª£ng h√†nh tinh
         */
        function focusOnObject(targetObject) {
            if (!targetObject || targetObject.userData.name === 'Sun') {
                // Focus M·∫∑t Tr·ªùi (To√†n c·∫£nh)
                currentFocusObject = null;
                focusTarget.set(0, 0, 0); 
                cameraRadius = 1300; 
                updateInfoPanel(PLANET_DATA.find(p => p.name === 'Sun'));
                updatePlanetListUI('Sun');
                updateFocusIndicator();
                return;
            }

            currentFocusObject = targetObject;
            
            // ƒê·∫∑t b√°n k√≠nh camera zoom d·ª±a tr√™n k√≠ch th∆∞·ªõc h√†nh tinh
            const baseDistance = targetObject.userData.size * 6; 
            cameraRadius = Math.max(10, baseDistance); 
            
            // ƒê·∫∑t g√≥c camera h∆°i ch√©o ƒë·ªÉ nh√¨n ƒë·∫πp h∆°n
            cameraAngle = { horizontal: 0.2, vertical: 0.3 };
            
            updateInfoPanel(targetObject.userData);
            updatePlanetListUI(targetObject.userData.name);
            updateFocusIndicator(); // Th√™m v√≤ng s√°ng focus
        }

        /**
         * C·∫≠p nh·∫≠t v·ªã tr√≠ camera d·ª±a tr√™n t·ªça ƒë·ªô c·ª±c v√† m·ª•c ti√™u focusTarget
         */
        function updateCameraPosition() {
            if (!camera) return;
            const maxVerticalAngle = Math.PI / 180 * 85;
            cameraAngle.vertical = Math.max(-maxVerticalAngle, Math.min(maxVerticalAngle, cameraAngle.vertical));

            const x = focusTarget.x + cameraRadius * Math.cos(cameraAngle.vertical) * Math.sin(cameraAngle.horizontal);
            const y = focusTarget.y + cameraRadius * Math.sin(cameraAngle.vertical);
            const z = focusTarget.z + cameraRadius * Math.cos(cameraAngle.vertical) * Math.cos(cameraAngle.horizontal);
            
            camera.position.set(x, y, z);
            camera.lookAt(focusTarget); 
            
            // ƒêi·ªÅu ch·ªânh hi·ªÉn th·ªã Annotation based on camera distance (NEW)
            if (earthAnnotation) {
                // Ch·ªâ hi·ªÉn th·ªã ch·∫•m ƒë·ªè khi camera ƒë·ªß g·∫ßn Tr√°i ƒê·∫•t (t∆∞∆°ng ƒë∆∞∆°ng zoom v√†o Tr√°i ƒê·∫•t)
                const isEarthFocused = currentFocusObject && currentFocusObject.userData.name === 'Earth';
                earthAnnotation.visible = isEarthFocused && cameraRadius < ANNOTATION_DISTANCE_THRESHOLD;
            }
        }

        /**
         * T·∫°o d·∫•u ch·∫•m ƒë·∫°i di·ªán cho v·ªã tr√≠ con ng∆∞·ªùi (Annotation) tr√™n Tr√°i ƒê·∫•t
         */
        function createEarthAnnotation() {
            if (!earth) return;

            const radius = earth.userData.size + 0.05; 
            const latRad = HANOI_LATITUDE * (Math.PI / 180);
            const lonRad = HANOI_LONGITUDE * (Math.PI / 180);

            // Chuy·ªÉn ƒë·ªïi t·ªça ƒë·ªô c·∫ßu sang Cartesian (cƒÉn ch·ªânh v·ªõi m√¥ h√¨nh Three.js m·∫∑c ƒë·ªãnh quay quanh Y)
            const x = radius * Math.cos(latRad) * Math.sin(lonRad);
            const y = radius * Math.sin(latRad);
            const z = radius * Math.cos(latRad) * Math.cos(lonRad);
            
            const geometry = new THREE.SphereGeometry(0.15, 16, 16); 
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.9, 
                depthTest: false // ƒê·∫£m b·∫£o lu√¥n hi·ªÉn th·ªã tr√™n b·ªÅ m·∫∑t 
            }); 
            
            earthAnnotation = new THREE.Mesh(geometry, material);
            earthAnnotation.position.set(x, y, z);
            earthAnnotation.name = "HumanAnnotation";
            earthAnnotation.visible = false; // Ban ƒë·∫ßu ·∫©n
            earth.add(earthAnnotation);
        }

        // T·∫°o n·ªÅn sao
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = []; 
            const starCount = 15000; 
            const starRange = 3000; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(starRange * 2);
                const y = THREE.MathUtils.randFloatSpread(starRange * 2);
                const z = THREE.MathUtils.randFloatSpread(starRange * 2);
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({ color: 0xeeeeff, size: 0.4, sizeAttenuation: true }); 
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // T·∫°o V√†nh ƒëai Ti·ªÉu h√†nh tinh
        function createAsteroidBelt() {
            const asteroidCount = 8000; 
            const beltInnerRadius = 150;
            const beltOuterRadius = 220; 
            const beltThickness = 10; 

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const material = new THREE.PointsMaterial({ 
                color: 0x999999, 
                size: 0.1, 
                sizeAttenuation: true, 
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < asteroidCount; i++) {
                const radius = THREE.MathUtils.randFloat(beltInnerRadius, beltOuterRadius);
                const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const y = THREE.MathUtils.randFloatSpread(beltThickness);

                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            asteroids = new THREE.Points(geometry, material);
            asteroids.userData.orbitSpeed = 0.3 * INITIAL_SPEED_FACTOR; 
            scene.add(asteroids);
        }

        // L·∫•y v·∫≠t li·ªáu d·ª±a tr√™n lo·∫°i h√†nh tinh (PBR settings)
        function getPlanetMaterial(data) {
            let roughness = 0.8;
            let metalness = 0.2;
            let color = data.color;
            
            return new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: roughness, 
                metalness: metalness 
            });
        }
        
        // T·∫°o danh s√°ch h√†nh tinh tr√™n UI
        function createPlanetList() {
            const list = document.getElementById('planet-list');
            list.innerHTML = '';
            
            const sunData = PLANET_DATA.find(p => p.name === 'Sun');
            let item = document.createElement('div');
            item.className = 'planet-item active';
            item.textContent = '‚òÄÔ∏è M·∫∑t Tr·ªùi (To√†n c·∫£nh)';
            item.dataset.planet = 'Sun';
            list.appendChild(item);
            
            PLANET_DATA.filter(p => p.name !== 'Sun').forEach(data => {
                let item = document.createElement('div');
                item.className = 'planet-item';
                item.textContent = data.name + (data.name === 'Earth' ? ' üåç' : '');
                item.dataset.planet = data.name;
                list.appendChild(item);
            });
            
            list.addEventListener('click', (event) => {
                const planetName = event.target.dataset.planet;
                if (planetName) {
                    const targetObject = solarSystemObjects.find(obj => obj.userData.name === planetName);
                    focusOnObject(targetObject);
                }
            });
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i active trong danh s√°ch UI
        function updatePlanetListUI(name) {
             document.querySelectorAll('.planet-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.planet === name) {
                    item.classList.add('active');
                }
            });
        }


        /**
         * Thi·∫øt l·∫≠p c·∫£nh 3D ban ƒë·∫ßu
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); 

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 4000); 
            focusOnObject(null); // Focus ban ƒë·∫ßu v√†o M·∫∑t Tr·ªùi
            updateCameraPosition(); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            // Thi·∫øt l·∫≠p Post-Processing cho hi·ªáu ·ª©ng Bloom
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.6, // radius
                0.05 // threshold
            );
            bloomPass.strength = 1.5; 
            composer.addPass(bloomPass);

            clock = new THREE.Clock();

            // √Ånh s√°ng m√¥i tr∆∞·ªùng (Ambient)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(ambientLight);

            // √Ånh s√°ng ƒëi·ªÉm (Point Light) t·∫°i v·ªã tr√≠ M·∫∑t Tr·ªùi
            const pointLight = new THREE.PointLight(0xffffff, 3.0, 3000); 
            pointLight.position.set(0, 0, 0);
            pointLight.castShadow = true; 
            pointLight.shadow.mapSize.width = 4096; 
            pointLight.shadow.mapSize.height = 4096;
            pointLight.shadow.radius = 2; 
            pointLight.shadow.camera.far = 1500; 
            scene.add(pointLight);

            createStars();
            createAsteroidBelt();

            // T·∫°o M·∫∑t Tr·ªùi (Sun)
            const sunData = PLANET_DATA.find(p => p.name === 'Sun');
            const sunGeometry = new THREE.SphereGeometry(sunData.size, 64, 64);
            const sunMaterial = new THREE.MeshStandardMaterial({ 
                color: sunData.color, 
                emissive: sunData.emissive, 
                emissiveIntensity: 5.0 
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.userData = sunData;
            sunMesh.name = sunData.name;
            scene.add(sunMesh);
            solarSystemObjects.push(sunMesh); 
            
            // V√≤ng Corona/H√†o quang M·∫∑t Tr·ªùi (cho hi·ªáu ·ª©ng th·ªã gi√°c)
            const coronaGeometry = new THREE.SphereGeometry(sunData.size * 1.5, 32, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: 0xfdd45c, transparent: true, opacity: 0.1, depthWrite: false, blending: THREE.AdditiveBlending, 
            });
            const coronaMesh = new THREE.Mesh(coronaGeometry, coronaMaterial);
            sunMesh.add(coronaMesh);


            // T·∫°o c√°c H√†nh tinh
            for (const data of PLANET_DATA) {
                if (data.name === 'Sun') continue;

                // Group cho Qu·ªπ ƒë·∫°o (ƒë·ªÉ d·ªÖ d√†ng ƒë·∫∑t ƒë·ªô nghi√™ng qu·ªπ ƒë·∫°o)
                const orbitGroup = new THREE.Group();
                if (data.inclination) {
                    orbitGroup.rotation.z = data.inclination;
                }
                scene.add(orbitGroup);

                const geometry = new THREE.SphereGeometry(data.size, 64, 64);
                const material = getPlanetMaterial(data); 
                const planetMesh = new THREE.Mesh(geometry, material);
                
                planetMesh.position.x = data.orbitRadius;
                planetMesh.receiveShadow = true; 
                planetMesh.castShadow = true;   
                planetMesh.name = data.name; 

                planetMesh.userData = data;
                orbitGroup.add(planetMesh);
                orbitGroup.userData.orbitSpeed = data.orbitSpeed;
                solarSystemObjects.push(planetMesh);

                if (data.name === 'Earth') {
                    earth = planetMesh;
                    createEarthAnnotation(); 

                    const atmosphereGeometry = new THREE.SphereGeometry(data.size * 1.05, 64, 64); 
                    const atmosphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x9fdeff, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.BackSide 
                    });
                    const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    planetMesh.add(atmosphereMesh); 
                    atmosphereMesh.receiveShadow = true;
                    
                    const cloudsGeometry = new THREE.SphereGeometry(data.size * 1.005, 64, 64); 
                    const cloudsMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff, transparent: true, opacity: 0.35, wireframe: true, wireframeLinewidth: 0.2 
                    });
                    earthClouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
                    planetMesh.add(earthClouds);
                }
                
                // V√†nh ƒêai Sao Th·ªï/Thi√™n V∆∞∆°ng (ƒê√£ FIX)
                if (data.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.8, 64);
                    
                    const ringMaterial = new THREE.MeshStandardMaterial({ 
                        color: data.ringColor, 
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        opacity: 0.9, 
                        roughness: 0.9 
                    });

                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    // Thi·∫øt l·∫≠p ƒë·ªô nghi√™ng tr·ª•c cho H√†nh tinh
                    const axialTilt = data.axialTilt || 0; 
                    planetMesh.rotation.x = axialTilt; 
                    
                    // Xoay v√≤ng ƒëai 90 ƒë·ªô ƒë·ªÉ n√≥ n·∫±m ngang, sau ƒë√≥ nghi√™ng theo planetMesh
                    ringMesh.rotation.x = Math.PI / 2; 
                    ringMesh.receiveShadow = true; 
                    planetMesh.add(ringMesh);
                }

                // V√≤ng Qu·ªπ ƒê·∫°o
                const orbitLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, opacity: 0.3, transparent: true }); 
                const points = [];
                for (let i = 0; i <= 360; i += 5) {
                    const angle = i * Math.PI / 180;
                    // V√≤ng qu·ªπ ƒë·∫°o n·∫±m tr√™n m·∫∑t ph·∫≥ng XY c·ªßa group qu·ªπ ƒë·∫°o (ƒë√£ xoay)
                    points.push(new THREE.Vector3(data.orbitRadius * Math.cos(angle), data.orbitRadius * Math.sin(angle), 0));
                }
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const orbitLine = new THREE.Line(orbitGeometry, orbitLineMaterial);
                orbitGroup.add(orbitLine); 
            }

            // M·∫∑t TrƒÉng (Moon)
            if (earth) {
                const moonOrbitRadius = 8;
                const moonGeometry = new THREE.SphereGeometry(1, 32, 32);
                const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 1.0, metalness: 0.05 });
                moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.position.x = moonOrbitRadius;
                moon.castShadow = true;
                moon.receiveShadow = true;
                earth.add(moon); 
            }
            
            // Thi·∫øt l·∫≠p c√°c s·ª± ki·ªán ƒëi·ªÅu khi·ªÉn
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            document.addEventListener('click', onPlanetClick, false); 
            
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);

            // X·ª≠ l√Ω thanh tr∆∞·ª£t t·ªëc ƒë·ªô
            const speedSlider = document.getElementById('speedSlider');
            const currentSpeedSpan = document.getElementById('currentSpeed');
            speedSlider.addEventListener('input', (event) => {
                globalSpeedMultiplier = parseFloat(event.target.value);
                currentSpeedSpan.textContent = globalSpeedMultiplier.toFixed(1);
            });
            
            document.getElementById('close-help').onclick = () => {
                document.getElementById('help-overlay').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('help-overlay').style.display = 'none';
                }, 500);
            };

            createPlanetList();
        }
        
        function onWindowResize() {
            if (camera && renderer && composer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight); 
            }
        }
        
        function onPlanetClick(event) {
            // Lo·∫°i tr·ª´ click v√†o UI panels
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay')) return;
            
            const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
            const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);

            if (!clientX || !clientY) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);

            const interactableObjects = solarSystemObjects;
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0) {
                // Ki·ªÉm tra xem c√≥ ph·∫£i l√† h√†nh tinh kh√¥ng (lo·∫°i tr·ª´ c√°c th√†nh ph·∫ßn nh·ªè nh∆∞ ch·∫•m ƒë·ªè)
                let clickedObject = intersects[0].object;
                if (clickedObject.name === "HumanAnnotation") {
                    clickedObject = clickedObject.parent; // Quay l·∫°i Tr√°i ƒê·∫•t
                }
                focusOnObject(clickedObject);
            } else {
                focusOnObject(null);
            }
        }
        
        function onMouseDown(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay')) return; 
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging || initialPinchDistance > 0) return; 
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            const rotationSpeed = 0.005;

            cameraAngle.horizontal -= deltaX * rotationSpeed;
            cameraAngle.vertical += deltaY * rotationSpeed;

            updateCameraPosition(); 
            
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseWheel(event) {
            // Zoom th√≠ch ·ª©ng: t·ªëc ƒë·ªô zoom ch·∫≠m h∆°n khi ·ªü g·∫ßn v√† nhanh h∆°n khi ·ªü xa
            const adaptiveZoomSpeed = cameraRadius * 0.0015; 
            cameraRadius += event.deltaY * adaptiveZoomSpeed;
            
            const minRadius = currentFocusObject ? 3 : 50;
            cameraRadius = Math.max(minRadius, Math.min(2000, cameraRadius)); 
            
            updateCameraPosition();
        }

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onTouchStart(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay')) return; 

            if (event.touches.length === 1) {
                event.preventDefault(); 
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                initialPinchDistance = 0;
            } else if (event.touches.length === 2) {
                event.preventDefault(); 
                isDragging = false; 
                initialPinchDistance = getDistance(event.touches[0], event.touches[1]);
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isDragging) {
                event.preventDefault(); 
                
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                const rotationSpeed = 0.007;

                cameraAngle.horizontal -= deltaX * rotationSpeed;
                cameraAngle.vertical += deltaY * rotationSpeed;

                updateCameraPosition(); 
                
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;

            } else if (event.touches.length === 2 && initialPinchDistance > 0) {
                event.preventDefault();

                const currentPinchDistance = getDistance(event.touches[0], event.touches[1]);
                const pinchDelta = currentPinchDistance - initialPinchDistance;

                // Zoom th√≠ch ·ª©ng: D√πng pinchDelta v√† t·ªâ l·ªá b√°n k√≠nh hi·ªán t·∫°i
                const adaptiveZoomSpeed = cameraRadius * 0.003; 

                cameraRadius -= pinchDelta * adaptiveZoomSpeed; 
                
                const minRadius = currentFocusObject ? 3 : 50;
                cameraRadius = Math.max(minRadius, Math.min(2000, cameraRadius)); 
                
                updateCameraPosition();
                
                initialPinchDistance = currentPinchDistance; 
            }
        }

        function onTouchEnd(event) {
            isDragging = false;
            if (event.touches.length < 2) { 
                initialPinchDistance = 0;
            }
        }


        /**
         * V√≤ng l·∫∑p ho·∫°t h√¨nh ch√≠nh
         */
        function animate() {
            requestAnimationFrame(animate);

            if (!composer || !scene || !camera || !clock) {
                return; 
            }
            
            const deltaTime = clock.getDelta(); 
            const effectiveDeltaTime = deltaTime * globalSpeedMultiplier;

            // 1. C·∫≠p nh·∫≠t v·ªã tr√≠ h√†nh tinh v√† c√°c v·∫≠t th·ªÉ
            for (const object of solarSystemObjects) {
                const data = object.userData;

                if (data.selfRotateSpeed) {
                    object.rotation.y += data.selfRotateSpeed * effectiveDeltaTime;
                }

                if (object.parent instanceof THREE.Group && object.parent.userData.orbitSpeed) {
                    object.parent.rotation.y += object.parent.userData.orbitSpeed * effectiveDeltaTime;
                }
            }
            
            if (earthClouds) {
                earthClouds.rotation.y += 0.05 * effectiveDeltaTime; 
            }

            if (asteroids && asteroids.userData.orbitSpeed) {
                asteroids.rotation.y += asteroids.userData.orbitSpeed * effectiveDeltaTime;
            }

            if (moon) {
                const moonSpeed = 2 * INITIAL_SPEED_FACTOR; 
                const moonRadius = 8;
                const moonGroupRotation = effectiveDeltaTime * moonSpeed;
                
                // Moon quay quanh Tr√°i ƒê·∫•t
                const moonOrbitGroup = new THREE.Group();
                moonOrbitGroup.rotation.y = moonGroupRotation;
                
                moon.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), moonGroupRotation);
                moon.rotation.y += 0.1 * effectiveDeltaTime;
            }
            
            // 2. C·∫≠p nh·∫≠t m·ª•c ti√™u focus v√† Camera
            if (currentFocusObject) {
                const targetPosition = new THREE.Vector3();
                currentFocusObject.getWorldPosition(targetPosition);
                
                // S·ª≠ d·ª•ng lerp ƒë·ªÉ chuy·ªÉn ƒë·ªông camera m∆∞·ª£t m√†
                focusTarget.lerp(targetPosition, 0.1); 
            }

            if (!isDragging && initialPinchDistance === 0) {
                updateCameraPosition();
            }
            
            // 3. C·∫≠p nh·∫≠t th√¥ng tin kho·∫£ng c√°ch theo th·ªùi gian th·ª±c (NEW)
            if (currentFocusObject && currentFocusObject.userData.name !== 'Sun') {
                const infoDistance = document.getElementById('info-distance');
                
                const currentPos = new THREE.Vector3();
                currentFocusObject.getWorldPosition(currentPos);
                
                // Kho·∫£ng c√°ch t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn M·∫∑t Tr·ªùi (0,0,0)
                const distance = currentPos.length(); 
                
                if (infoDistance) {
                    infoDistance.textContent = `${distance.toFixed(2)} AU (m√¥ ph·ªèng)`;
                }
            }

            // Render
            composer.render();
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        window.onload = function () {
            try {
                init();
                animate();
            } catch (error) {
                console.error("L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o ho·∫∑c ho·∫°t h√¨nh:", error);
                // Hi·ªÉn th·ªã th√¥ng b√°o l·ªói th√¢n thi·ªán n·∫øu kh√¥ng th·ªÉ kh·ªüi t·∫°o
                document.body.innerHTML = `
                    <div class="p-8 text-center text-red-500 bg-gray-900 absolute inset-0 flex items-center justify-center flex-col">
                        <h1 class="text-3xl font-bold mb-4">L·ªói Kh·ªüi t·∫°o 3D</h1>
                        <p class="text-lg">C√≥ v·∫ª nh∆∞ tr√¨nh duy·ªát c·ªßa b·∫°n g·∫∑p s·ª± c·ªë khi ch·∫°y m√¥ ph·ªèng 3D. Vui l√≤ng ki·ªÉm tra console ho·∫∑c th·ª≠ l·∫°i.</p>
                        <p class="text-sm mt-3">Chi ti·∫øt l·ªói: ${error.message}</p>
                    </div>`;
            }
        }
    </script>
</body>
</html>
