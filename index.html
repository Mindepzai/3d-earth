<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng H·ªá M·∫∑t Tr·ªùi 3D - Phi√™n b·∫£n T·ªëi ∆∞u Di ƒë·ªông</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Th∆∞ vi·ªán Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-Processing dependencies for Bloom Effect -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/ConvolutionShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    
    <style>
        /* T·ªëi ∆∞u h√≥a CSS cho di ƒë·ªông v√† m√°y t√≠nh */
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #0d1117;
            font-family: 'Inter', sans-serif;
            color: white;
            touch-action: none; /* NgƒÉn ch·∫∑n h√†nh vi m·∫∑c ƒë·ªãnh c·ªßa tr√¨nh duy·ªát */
        }
        canvas {
            display: block;
        }
        
        #controls, #info-panel {
            position: absolute;
            padding: 0.75rem;
            background: rgba(17, 24, 39, 0.95); 
            border-radius: 12px;
            z-index: 100;
            user-select: none;
            border: 1px solid rgba(55, 65, 81, 0.5);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.7);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto; /* Cho ph√©p t∆∞∆°ng t√°c */
        }

        #controls {
            top: 1rem;
            left: 1rem;
            width: 250px;
        }
        
        /* N√∫t ·∫©n/hi·ªán ƒëi·ªÅu khi·ªÉn */
        #controls-toggle {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 101;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            background: #1d4ed8; /* Blue 700 */
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
        }

        /* T√πy ch·ªânh cho Mobile (m√†n h√¨nh nh·ªè h∆°n 640px) */
        @media (max-width: 640px) {
            #controls-content {
                /* M·∫∑c ƒë·ªãnh ·∫©n n·ªôi dung tr√™n mobile */
                transform: translateX(-110%); 
                opacity: 0;
                pointer-events: none;
                transition: transform 0.3s, opacity 0.3s;
            }
            
            #controls.open #controls-content {
                /* Hi·ªÉn th·ªã khi c√≥ class 'open' */
                transform: translateX(0);
                opacity: 1;
                pointer-events: auto;
            }

            #controls {
                /* Khi m·ªü, b·∫£ng ƒëi·ªÅu khi·ªÉn c·ªë ƒë·ªãnh */
                position: fixed;
                width: calc(100vw - 2rem);
                max-width: 300px;
                padding: 0.5rem;
                top: 0.5rem;
                left: 0.5rem;
            }
            
            #controls-toggle {
                /* N√∫t toggle n·∫±m ngo√†i b·∫£ng ƒëi·ªÅu khi·ªÉn ƒë√£ ·∫©n */
                position: fixed;
                top: 0.5rem;
                left: 0.5rem;
            }
        }
        
        /* B·∫£ng Th√¥ng tin: lu√¥n ·ªü g√≥c d∆∞·ªõi b√™n ph·∫£i */
        #info-panel {
            bottom: 1rem; 
            right: 1rem;
            top: auto; 
            width: 300px;
            max-width: calc(100vw - 2rem); 
            display: none; /* M·∫∑c ƒë·ªãnh ·∫©n */
        }
        
        /* Thanh tr∆∞·ª£t */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 8px;
            background: #374151;
            border-radius: 4px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #10b981;
            cursor: pointer;
            box-shadow: 0 0 5px rgba(16, 185, 129, 0.5);
        }
        
        #planet-list {
            max-height: 250px;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #4b5563 #111827; 
        }

        .planet-item {
            padding: 0.5rem;
            margin-bottom: 0.25rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.15s;
            font-size: 0.875rem;
        }
        .planet-item.active {
            background-color: #3b82f6;
            font-weight: bold;
        }
    </style>
</head>
<body>
    
    <!-- N√∫t Toggle Controls (Lu√¥n hi·ªÉn th·ªã tr√™n Mobile) -->
    <div id="controls-toggle" class="text-white" onclick="toggleControls()">
        ‚öôÔ∏è
    </div>

    <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn (T·ªëc ƒë·ªô v√† Danh s√°ch) -->
    <div id="controls">
        <div id="controls-content" class="space-y-4">
            <h2 class="text-lg font-bold text-blue-400 border-b border-gray-700 pb-1">ƒêi·ªÅu khi·ªÉn M√¥ ph·ªèng</h2>
            
            <!-- Thanh ƒëi·ªÅu khi·ªÉn t·ªëc ƒë·ªô -->
            <div class="control-group">
                <label for="speedSlider" class="text-sm font-medium text-gray-300">T·ªëc ƒë·ªô: <span id="currentSpeed">1.0</span>x</label>
                <input type="range" id="speedSlider" min="0.1" max="5.0" step="0.1" value="1.0">
            </div>
            
            <!-- Danh s√°ch ch·ªçn h√†nh tinh -->
            <div class="control-group">
                <label class="text-sm font-medium text-gray-300 mb-2 block">T·∫≠p trung Camera</label>
                <div id="planet-list" class="bg-gray-800/70 p-1 rounded-lg">
                    <!-- Danh s√°ch h√†nh tinh ƒë∆∞·ª£c ch√®n b·∫±ng JS -->
                </div>
            </div>
        </div>
    </div>

    <!-- B·∫£ng th√¥ng tin H√†nh tinh (·∫®n/Hi·ªán b·∫±ng t∆∞∆°ng t√°c) -->
    <div id="info-panel">
        <div class="flex justify-between items-center mb-2 border-b border-gray-600 pb-2">
            <h2 id="planet-name-title" class="text-xl font-bold text-yellow-300">Th√¥ng tin</h2>
            <button onclick="hideInfoPanel()" class="text-gray-400 hover:text-white text-lg font-bold p-1 rounded transition bg-gray-700/50">
                &times;
            </button>
        </div>

        <div id="planet-details" class="text-sm space-y-2">
            <p class="info-detail">T√™n: <strong id="info-name"></strong></p>
            <p class="info-detail">K√≠ch th∆∞·ªõc (Rel.): <strong id="info-size"></strong></p>
            <p class="info-detail">B√°n k√≠nh Qu·ªπ ƒë·∫°o (Rel.): <strong id="info-orbit"></strong></p>
            <p class="info-detail">Kho·∫£ng c√°ch ƒë·∫øn MT (T·ª©c th·ªùi): <strong id="info-distance" class="text-green-400"></strong></p>
            <p class="info-detail">T·ªëc ƒë·ªô Qu·ªπ ƒë·∫°o: <strong id="info-speed"></strong></p>
        </div>

        <!-- Static Description Content -->
        <div id="info-description" class="mt-4 p-3 rounded-lg bg-gray-700/60 text-sm italic text-gray-200">
            <!-- M√¥ t·∫£ s·∫Ω ƒë∆∞·ª£c ch√®n b·∫±ng JS -->
        </div>
    </div>
    
    <!-- Overlay H∆∞·ªõng d·∫´n -->
    <div id="help-overlay" class="fixed inset-0 bg-black bg-opacity-80 flex items-center justify-center z-[200] transition-opacity duration-500">
        <div class="bg-gray-900 p-6 rounded-xl shadow-2xl max-w-sm mx-4 border border-blue-700">
            <h3 class="text-2xl font-extrabold text-blue-400 mb-4">Kh√°m ph√° H·ªá M·∫∑t Tr·ªùi ü™ê</h3>
            <ul class="text-sm space-y-3 text-gray-300">
                <li><strong class="text-white">Di chuy·ªÉn/Quay:</strong> Gi·ªØ chu·ªôt tr√°i (PC) ho·∫∑c ch·∫°m v√† k√©o (Mobile) ƒë·ªÉ xoay camera.</li>
                <li><strong class="text-white">Zoom:</strong> Cu·ªôn chu·ªôt (PC) ho·∫∑c d√πng hai ng√≥n tay ch·ª•m/t√°ch (Mobile).</li>
                <li><strong class="text-white">T·∫≠p trung:</strong> Nh·∫•n v√†o t√™n h√†nh tinh trong menu ho·∫∑c nh·∫•n tr·ª±c ti·∫øp v√†o h√†nh tinh.</li>
                <li><strong class="text-red-400">Ch·∫•m ƒë·ªè:</strong> Bi·ªÉu th·ªã v·ªã tr√≠ c·ªßa b·∫°n tr√™n Tr√°i ƒê·∫•t (ch·ªâ hi·ªán khi zoom g·∫ßn).</li>
            </ul>
            <button id="close-help" class="btn bg-blue-600 hover:bg-blue-700 text-white w-full mt-5 p-2 rounded-lg font-medium">
                B·∫Øt ƒë·∫ßu kh√°m ph√°
            </button>
        </div>
    </div>


    <script>
        // === KHAI B√ÅO BI·∫æN TO√ÄN C·ª§C ===
        let scene = null;
        let camera = null;
        let renderer = null;
        let composer = null; 
        let clock = null;
        let solarSystemObjects = []; 
        let asteroids = null; 
        let moon = null;
        let earthClouds = null;
        let globalSpeedMultiplier = 1.0; 
        
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRadius = 1300; 
        let cameraAngle = { horizontal: 0, vertical: 0.4 }; 
        let focusTarget = new THREE.Vector3(0, 0, 0); 
        let currentFocusObject = null; 
        let initialPinchDistance = 0; 
        
        let focusIndicator = null; 
        
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        
        const INITIAL_SPEED_FACTOR = 0.5;

        // T·ªça ƒë·ªô ng∆∞·ªùi tr√™n Tr√°i ƒê·∫•t (ƒê·∫°i di·ªán cho H√† N·ªôi, Vi·ªát Nam)
        const HANOI_LATITUDE = 21.0285;
        const HANOI_LONGITUDE = 105.8542;
        let earth = null;
        let earthAnnotation = null; 
        const ANNOTATION_DISTANCE_THRESHOLD = 50; 

        // D·ªØ li·ªáu H√†nh tinh (ƒê√£ ch·ªânh s·ª≠a th√¥ng s·ªë ƒë·ªÉ m√¥ ph·ªèng t·ªët h∆°n)
        const PLANET_DATA = [
            { name: 'Sun', size: 15, color: 0xffffff, emissive: 0xfdd45c, orbitRadius: 0, orbitSpeed: 0 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 0 }, 
            { name: 'Mercury', size: 1.0, color: 0x808080, orbitRadius: 30, orbitSpeed: 1.5 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.1 * INITIAL_SPEED_FACTOR, inclination: 7 * (Math.PI / 180) },
            { name: 'Venus', size: 2.5, color: 0xd2b48c, orbitRadius: 55, orbitSpeed: 1.0 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 3.4 * (Math.PI / 180) },
            { name: 'Earth', size: 3, color: 0x0088ff, orbitRadius: 90, orbitSpeed: 0.5 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.5 * INITIAL_SPEED_FACTOR, hasMoon: true, inclination: 0.0 * (Math.PI / 180) }, 
            { name: 'Mars', size: 1.5, color: 0xa0522d, orbitRadius: 130, orbitSpeed: 0.4 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.8 * INITIAL_SPEED_FACTOR, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Jupiter', size: 8, color: 0xd3a373, orbitRadius: 250, orbitSpeed: 0.2 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 1.5 * INITIAL_SPEED_FACTOR, inclination: 1.3 * (Math.PI / 180) },
            { name: 'Saturn', size: 6, color: 0xf5deb3, orbitRadius: 400, orbitSpeed: 0.15 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 1.2 * INITIAL_SPEED_FACTOR, hasRings: true, inclination: 2.5 * (Math.PI / 180), ringColor: 0x776655, axialTilt: 26.7 * (Math.PI / 180) }, 
            { name: 'Uranus', size: 4, color: 0xafdfe4, orbitRadius: 650, orbitSpeed: 0.1 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.8 * INITIAL_SPEED_FACTOR, hasRings: true, inclination: 0.77 * (Math.PI / 180), ringColor: 0xeeeeff, axialTilt: 98 * (Math.PI / 180) },
            { name: 'Neptune', size: 4, color: 0x00008b, orbitRadius: 900, orbitSpeed: 0.07 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.7 * INITIAL_SPEED_FACTOR, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Pluto', size: 0.5, color: 0xcccccc, orbitRadius: 1150, orbitSpeed: 0.03 * INITIAL_SPEED_FACTOR, selfRotateSpeed: 0.05 * INITIAL_SPEED_FACTOR, inclination: 17 * (Math.PI / 180) },
        ];
        
        // === D·ªÆ LI·ªÜU M√î T·∫¢ Tƒ®NH ===
        const PLANET_DESCRIPTIONS = {
            'Sun': "M·∫∑t Tr·ªùi l√† ng√¥i sao trung t√¢m, chi·∫øm 99.8% kh·ªëi l∆∞·ª£ng H·ªá M·∫∑t Tr·ªùi. NƒÉng l∆∞·ª£ng t·ª´ M·∫∑t Tr·ªùi, t·∫°o ra t·ª´ ph·∫£n ·ª©ng nhi·ªát h·∫°ch, l√† ngu·ªìn s·ªëng v√† √°nh s√°ng thi·∫øt y·∫øu cho m·ªçi h√†nh tinh.",
            'Mercury': "Th·ªßy tinh l√† h√†nh tinh nh·ªè nh·∫•t v√† g·∫ßn M·∫∑t Tr·ªùi nh·∫•t, c√≥ b·ªÅ m·∫∑t ƒë·∫ßy c√°c h·ªë va ch·∫°m t∆∞∆°ng t·ª± M·∫∑t TrƒÉng. N√≥ c√≥ s·ª± ch√™nh l·ªách nhi·ªát ƒë·ªô l·ªõn nh·∫•t trong h·ªá.",
            'Venus': "Sao Kim l√† h√†nh tinh n√≥ng nh·∫•t do hi·ªáu ·ª©ng nh√† k√≠nh c·ª±c m·∫°nh, b·ªã bao ph·ªß b·ªüi b·∫ßu kh√≠ quy·ªÉn d√†y ƒë·∫∑c g·ªìm carbon dioxide v√† m√¢y axit sulfuric.",
            'Earth': "Tr√°i ƒê·∫•t l√† h√†nh tinh duy nh·∫•t ƒë∆∞·ª£c bi·∫øt ƒë·∫øn c√≥ s·ª± s·ªëng, v·ªõi 71% b·ªÅ m·∫∑t l√† n∆∞·ªõc l·ªèng. B·∫ßu kh√≠ quy·ªÉn v√† t·ª´ tr∆∞·ªùng c·ªßa n√≥ l√† l·ªõp b·∫£o v·ªá ho√†n h·∫£o.",
            'Mars': "Sao H·ªèa, hay H√†nh tinh ƒê·ªè, c√≥ m√†u s·∫Øc ƒë·∫∑c tr∆∞ng do oxit s·∫Øt. N√≥ c√≥ ng·ªçn n√∫i l·ª≠a cao nh·∫•t (Olympus Mons) v√† h·∫ªm n√∫i s√¢u nh·∫•t (Valles Marineris) ƒë√£ t·ª´ng ƒë∆∞·ª£c bi·∫øt ƒë·∫øn.",
            'Jupiter': "Sao M·ªôc l√† h√†nh tinh l·ªõn nh·∫•t, l√† m·ªôt ng∆∞·ªùi kh·ªïng l·ªì kh√≠, ƒë∆∞·ª£c bi·∫øt ƒë·∫øn v·ªõi V·∫øt ƒê·ªè L·ªõn, m·ªôt c∆°n b√£o kh·ªïng l·ªì t·ªìn t·∫°i h√†ng th·∫ø k·ª∑.",
            'Saturn': "Sao Th·ªï n·ªïi ti·∫øng nh·∫•t v·ªõi h·ªá th·ªëng v√†nh ƒëai ngo·∫°n m·ª•c, ch·ªß y·∫øu l√†m t·ª´ bƒÉng v√† ƒë√°. ƒê√¢y l√† h√†nh tinh c√≥ m·∫≠t ƒë·ªô th·∫•p nh·∫•t, nh·∫π h∆°n n∆∞·ªõc.",
            'Uranus': "Sao Thi√™n V∆∞∆°ng l√† m·ªôt h√†nh tinh kh·ªïng l·ªì bƒÉng, ƒë·ªôc ƒë√°o v·ªõi tr·ª•c quay b·ªã nghi√™ng g·∫ßn nh∆∞ song song v·ªõi m·∫∑t ph·∫≥ng qu·ªπ ƒë·∫°o (98 ƒë·ªô).",
            'Neptune': "Sao H·∫£i V∆∞∆°ng l√† h√†nh tinh kh·ªïng l·ªì bƒÉng ngo√†i c√πng, l√† n∆°i c√≥ nh·ªØng c∆°n gi√≥ m·∫°nh nh·∫•t t·ª´ng ƒë∆∞·ª£c ghi nh·∫≠n. N√≥ l·∫°nh l·∫Ωo, t·ªëi tƒÉm v√† c√≥ m√†u xanh ƒë·∫≠m n·ªïi b·∫≠t.",
            'Pluto': "Sao Di√™m V∆∞∆°ng l√† m·ªôt h√†nh tinh l√πn thu·ªôc V√†nh ƒëai Kuiper. M·∫∑c d√π nh·ªè b√©, n√≥ c√≥ ƒë·ªãa h√¨nh ƒëa d·∫°ng bao g·ªìm n√∫i bƒÉng v√† ƒë·ªìng b·∫±ng nito ƒë√¥ng l·∫°nh (tr√°i tim c·ªßa Sao Di√™m V∆∞∆°ng)."
        };

        // === LOGIC T∆Ø∆†NG T√ÅC UI (M·ªöI CHO MOBILE) ===
        function toggleControls() {
            const controls = document.getElementById('controls');
            controls.classList.toggle('open');
            
            // Di chuy·ªÉn n√∫t toggle khi b·∫£ng ƒëi·ªÅu khi·ªÉn m·ªü/ƒë√≥ng
            const toggleButton = document.getElementById('controls-toggle');
            if (controls.classList.contains('open')) {
                 // Di chuy·ªÉn n√∫t toggle ra b√™n ph·∫£i b·∫£ng controls khi m·ªü
                if (window.innerWidth <= 640) {
                    toggleButton.style.left = 'calc(0.5rem + ' + controls.offsetWidth + 'px)';
                } else {
                    // PC: n√∫t toggle n·∫±m tr√™n controls (kh√¥ng c·∫ßn di chuy·ªÉn)
                    toggleButton.style.left = '1rem'; 
                }
                toggleButton.innerHTML = '‚ùå'; 
            } else {
                toggleButton.style.left = '0.5rem';
                toggleButton.innerHTML = '‚öôÔ∏è'; 
            }
        }
        
        function hideInfoPanel() {
            document.getElementById('info-panel').style.display = 'none';
        }
        
        // ƒê·∫£m b·∫£o n√∫t toggle ƒë∆∞·ª£c ƒë·∫∑t l·∫°i v·ªã tr√≠ khi thay ƒë·ªïi k√≠ch th∆∞·ªõc m√†n h√¨nh
        function adjustTogglePosition() {
             const controls = document.getElementById('controls');
             const toggleButton = document.getElementById('controls-toggle');
             if (window.innerWidth > 640) {
                // Tr√™n PC, ·∫©n n√∫t toggle v√† hi·ªÉn th·ªã controls
                toggleButton.style.display = 'none';
                controls.classList.add('open');
                controls.style.position = 'absolute';
                controls.style.width = '250px';
                controls.style.left = '1rem';
                document.getElementById('controls-content').style.transform = 'translateX(0)';
                document.getElementById('controls-content').style.opacity = '1';
                document.getElementById('controls-content').style.pointerEvents = 'auto';

             } else {
                // Tr√™n Mobile, hi·ªÉn th·ªã n√∫t toggle
                toggleButton.style.display = 'flex';
                controls.style.position = 'fixed';
                if (controls.classList.contains('open')) {
                    toggleButton.style.left = 'calc(0.5rem + ' + controls.offsetWidth + 'px)';
                } else {
                    toggleButton.style.left = '0.5rem';
                }
             }
        }


        /**
         * Th√™m ho·∫∑c c·∫≠p nh·∫≠t v√≤ng s√°ng focus xung quanh h√†nh tinh
         */
        function updateFocusIndicator() {
            if (focusIndicator) {
                focusIndicator.parent.remove(focusIndicator);
                focusIndicator.geometry.dispose();
                focusIndicator.material.dispose();
                focusIndicator = null;
            }

            if (currentFocusObject && currentFocusObject.userData.name !== 'Sun') {
                const size = currentFocusObject.userData.size;
                
                const indicatorGeometry = new THREE.RingGeometry(size * 1.5, size * 1.6, 64);
                const indicatorMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffa500, 
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.35,
                    depthWrite: false, 
                    blending: THREE.AdditiveBlending 
                });

                focusIndicator = new THREE.Mesh(indicatorGeometry, indicatorMaterial);
                focusIndicator.rotation.x = Math.PI / 2; 
                focusIndicator.name = "FocusIndicator";

                currentFocusObject.add(focusIndicator);
            }
        }

        /**
         * C·∫≠p nh·∫≠t th√¥ng tin tr√™n b·∫£ng Info Panel
         */
        function updateInfoPanel(data) {
            const panel = document.getElementById('info-panel');
            const nameTitle = document.getElementById('planet-name-title');
            const infoName = document.getElementById('info-name');
            const infoSize = document.getElementById('info-size');
            const infoOrbit = document.getElementById('info-orbit');
            const infoSpeed = document.getElementById('info-speed');
            const infoDistance = document.getElementById('info-distance'); 
            const infoDescription = document.getElementById('info-description'); 
            
            if (!data) {
                panel.style.display = 'none';
                return;
            }

            // Lu√¥n hi·ªÉn th·ªã b·∫£ng th√¥ng tin khi ch·ªçn h√†nh tinh m·ªõi
            panel.style.display = 'block'; 
            nameTitle.textContent = data.name;
            infoName.textContent = data.name;
            infoSize.textContent = `${data.size.toFixed(1)} ƒë∆°n v·ªã`;
            infoOrbit.textContent = `${data.orbitRadius.toFixed(1)} AU (m√¥ ph·ªèng)`;
            infoSpeed.textContent = `${(data.orbitSpeed / INITIAL_SPEED_FACTOR).toFixed(2)} ƒë∆°n v·ªã/s`;
            
            infoDescription.textContent = PLANET_DESCRIPTIONS[data.name] || "Kh√¥ng c√≥ th√¥ng tin m√¥ t·∫£ cho v·∫≠t th·ªÉ n√†y.";

            if (data.name === 'Sun') {
                 infoDistance.textContent = '0.00 AU';
            } else {
                 infoDistance.textContent = 'ƒêang t√≠nh...';
            }
        }

        /**
         * Thi·∫øt l·∫≠p camera t·∫≠p trung v√†o m·ªôt ƒë·ªëi t∆∞·ª£ng h√†nh tinh
         */
        function focusOnObject(targetObject) {
            if (!targetObject || targetObject.userData.name === 'Sun') {
                currentFocusObject = null;
                focusTarget.set(0, 0, 0); 
                cameraRadius = 1300; 
                updateInfoPanel(PLANET_DATA.find(p => p.name === 'Sun'));
                updatePlanetListUI('Sun');
                updateFocusIndicator();
                return;
            }

            currentFocusObject = targetObject;
            
            const baseDistance = targetObject.userData.size * 6; 
            cameraRadius = Math.max(10, baseDistance); 
            
            cameraAngle = { horizontal: 0.2, vertical: 0.3 };
            
            updateInfoPanel(targetObject.userData);
            updatePlanetListUI(targetObject.userData.name);
            updateFocusIndicator(); 
        }

        /**
         * C·∫≠p nh·∫≠t v·ªã tr√≠ camera d·ª±a tr√™n t·ªça ƒë·ªô c·ª±c v√† m·ª•c ti√™u focusTarget
         */
        function updateCameraPosition() {
            if (!camera) return;
            const maxVerticalAngle = Math.PI / 180 * 85;
            cameraAngle.vertical = Math.max(-maxVerticalAngle, Math.min(maxVerticalAngle, cameraAngle.vertical));

            const x = focusTarget.x + cameraRadius * Math.cos(cameraAngle.vertical) * Math.sin(cameraAngle.horizontal);
            const y = focusTarget.y + cameraRadius * Math.sin(cameraAngle.vertical);
            const z = focusTarget.z + cameraRadius * Math.cos(cameraAngle.vertical) * Math.cos(cameraAngle.horizontal);
            
            camera.position.set(x, y, z);
            camera.lookAt(focusTarget); 
            
            if (earthAnnotation) {
                const isEarthFocused = currentFocusObject && currentFocusObject.userData.name === 'Earth';
                earthAnnotation.visible = isEarthFocused && cameraRadius < ANNOTATION_DISTANCE_THRESHOLD;
            }
        }

        /**
         * T·∫°o d·∫•u ch·∫•m ƒë·∫°i di·ªán cho v·ªã tr√≠ con ng∆∞·ªùi (Annotation) tr√™n Tr√°i ƒê·∫•t
         */
        function createEarthAnnotation() {
            if (!earth) return;

            const radius = earth.userData.size + 0.05; 
            const latRad = HANOI_LATITUDE * (Math.PI / 180);
            const lonRad = HANOI_LONGITUDE * (Math.PI / 180);

            const x = radius * Math.cos(latRad) * Math.sin(lonRad);
            const y = radius * Math.sin(latRad);
            const z = radius * Math.cos(latRad) * Math.cos(lonRad);
            
            const geometry = new THREE.SphereGeometry(0.15, 16, 16); 
            const material = new THREE.MeshBasicMaterial({ 
                color: 0xff0000, 
                transparent: true, 
                opacity: 0.9, 
                depthTest: false 
            }); 
            
            earthAnnotation = new THREE.Mesh(geometry, material);
            earthAnnotation.position.set(x, y, z);
            earthAnnotation.name = "HumanAnnotation";
            earthAnnotation.visible = false; 
            earth.add(earthAnnotation);
        }

        // T·∫°o n·ªÅn sao
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = []; 
            const starCount = 15000; 
            const starRange = 3000; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(starRange * 2);
                const y = THREE.MathUtils.randFloatSpread(starRange * 2);
                const z = THREE.MathUtils.randFloatSpread(starRange * 2);
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({ color: 0xeeeeff, size: 0.4, sizeAttenuation: true }); 
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        // T·∫°o V√†nh ƒëai Ti·ªÉu h√†nh tinh
        function createAsteroidBelt() {
            const asteroidCount = 8000; 
            const beltInnerRadius = 150;
            const beltOuterRadius = 220; 
            const beltThickness = 10; 

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const material = new THREE.PointsMaterial({ 
                color: 0x999999, 
                size: 0.1, 
                sizeAttenuation: true, 
                transparent: true, 
                opacity: 0.6
            });

            for (let i = 0; i < asteroidCount; i++) {
                const radius = THREE.MathUtils.randFloat(beltInnerRadius, beltOuterRadius);
                const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const y = THREE.MathUtils.randFloatSpread(beltThickness);

                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            asteroids = new THREE.Points(geometry, material);
            asteroids.userData.orbitSpeed = 0.3 * INITIAL_SPEED_FACTOR; 
            scene.add(asteroids);
        }

        // L·∫•y v·∫≠t li·ªáu d·ª±a tr√™n lo·∫°i h√†nh tinh (PBR settings)
        function getPlanetMaterial(data) {
            let roughness = 0.8;
            let metalness = 0.2;
            let color = data.color;
            
            return new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: roughness, 
                metalness: metalness 
            });
        }
        
        // T·∫°o danh s√°ch h√†nh tinh tr√™n UI
        function createPlanetList() {
            const list = document.getElementById('planet-list');
            list.innerHTML = '';
            
            const sunData = PLANET_DATA.find(p => p.name === 'Sun');
            let item = document.createElement('div');
            item.className = 'planet-item active';
            item.textContent = '‚òÄÔ∏è M·∫∑t Tr·ªùi (To√†n c·∫£nh)';
            item.dataset.planet = 'Sun';
            list.appendChild(item);
            
            PLANET_DATA.filter(p => p.name !== 'Sun').forEach(data => {
                let item = document.createElement('div');
                item.className = 'planet-item';
                item.textContent = data.name + (data.name === 'Earth' ? ' üåç' : '');
                item.dataset.planet = data.name;
                list.appendChild(item);
            });
            
            list.addEventListener('click', (event) => {
                const planetName = event.target.dataset.planet;
                if (planetName) {
                    const targetObject = solarSystemObjects.find(obj => obj.userData.name === planetName);
                    focusOnObject(targetObject);
                    // ƒê√≥ng controls sau khi ch·ªçn h√†nh tinh tr√™n mobile
                    if (window.innerWidth <= 640) {
                        toggleControls();
                    }
                }
            });
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i active trong danh s√°ch UI
        function updatePlanetListUI(name) {
             document.querySelectorAll('.planet-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.planet === name) {
                    item.classList.add('active');
                }
            });
        }


        /**
         * Thi·∫øt l·∫≠p c·∫£nh 3D ban ƒë·∫ßu
         */
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); 

            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 4000); 
            focusOnObject(null); 
            updateCameraPosition(); 
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            // Thi·∫øt l·∫≠p Post-Processing cho hi·ªáu ·ª©ng Bloom
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.6, // radius
                0.05 // threshold
            );
            bloomPass.strength = 1.5; 
            composer.addPass(bloomPass);

            clock = new THREE.Clock();

            // √Ånh s√°ng
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xffffff, 3.0, 3000); 
            pointLight.position.set(0, 0, 0);
            pointLight.castShadow = true; 
            pointLight.shadow.mapSize.width = 4096; 
            pointLight.shadow.mapSize.height = 4096;
            pointLight.shadow.radius = 2; 
            pointLight.shadow.camera.far = 1500; 
            scene.add(pointLight);

            createStars();
            createAsteroidBelt();

            // T·∫°o M·∫∑t Tr·ªùi (Sun)
            const sunData = PLANET_DATA.find(p => p.name === 'Sun');
            const sunGeometry = new THREE.SphereGeometry(sunData.size, 64, 64);
            const sunMaterial = new THREE.MeshStandardMaterial({ 
                color: sunData.color, 
                emissive: sunData.emissive, 
                emissiveIntensity: 5.0 
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.userData = sunData;
            sunMesh.name = sunData.name;
            scene.add(sunMesh);
            solarSystemObjects.push(sunMesh); 
            
            const coronaGeometry = new THREE.SphereGeometry(sunData.size * 1.5, 32, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: 0xfdd45c, transparent: true, opacity: 0.1, depthWrite: false, blending: THREE.AdditiveBlending, 
            });
            const coronaMesh = new THREE.Mesh(coronaGeometry, coronaMaterial);
            sunMesh.add(coronaMesh);


            // T·∫°o c√°c H√†nh tinh
            for (const data of PLANET_DATA) {
                if (data.name === 'Sun') continue;

                const orbitGroup = new THREE.Group();
                if (data.inclination) {
                    orbitGroup.rotation.z = data.inclination;
                }
                scene.add(orbitGroup);

                const geometry = new THREE.SphereGeometry(data.size, 64, 64);
                const material = getPlanetMaterial(data); 
                const planetMesh = new THREE.Mesh(geometry, material);
                
                planetMesh.position.x = data.orbitRadius;
                planetMesh.receiveShadow = true; 
                planetMesh.castShadow = true;   
                planetMesh.name = data.name; 

                planetMesh.userData = data;
                orbitGroup.add(planetMesh);
                orbitGroup.userData.orbitSpeed = data.orbitSpeed;
                solarSystemObjects.push(planetMesh);

                if (data.name === 'Earth') {
                    earth = planetMesh;
                    createEarthAnnotation(); 

                    const atmosphereGeometry = new THREE.SphereGeometry(data.size * 1.05, 64, 64); 
                    const atmosphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x9fdeff, transparent: true, opacity: 0.15, depthWrite: false, side: THREE.BackSide 
                    });
                    const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    planetMesh.add(atmosphereMesh); 
                    
                    const cloudsGeometry = new THREE.SphereGeometry(data.size * 1.005, 64, 64); 
                    const cloudsMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff, transparent: true, opacity: 0.35, wireframe: true, wireframeLinewidth: 0.2 
                    });
                    earthClouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
                    planetMesh.add(earthClouds);
                }
                
                // V√†nh ƒêai
                if (data.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.8, 64);
                    
                    const ringMaterial = new THREE.MeshStandardMaterial({ 
                        color: data.ringColor, 
                        side: THREE.DoubleSide, 
                        transparent: true, 
                        opacity: 0.9, 
                        roughness: 0.9 
                    });

                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    const axialTilt = data.axialTilt || 0; 
                    planetMesh.rotation.x = axialTilt; 
                    
                    ringMesh.rotation.x = Math.PI / 2; 
                    ringMesh.receiveShadow = true; 
                    planetMesh.add(ringMesh);
                }

                // V√≤ng Qu·ªπ ƒê·∫°o
                const orbitLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666, opacity: 0.3, transparent: true }); 
                const points = [];
                for (let i = 0; i <= 360; i += 5) {
                    const angle = i * Math.PI / 180;
                    points.push(new THREE.Vector3(data.orbitRadius * Math.cos(angle), data.orbitRadius * Math.sin(angle), 0));
                }
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const orbitLine = new THREE.Line(orbitGeometry, orbitLineMaterial);
                orbitGroup.add(orbitLine); 
            }

            // M·∫∑t TrƒÉng (Moon)
            if (earth) {
                const moonOrbitRadius = 8;
                const moonGeometry = new THREE.SphereGeometry(1, 32, 32);
                const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 1.0, metalness: 0.05 });
                moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.position.x = moonOrbitRadius;
                moon.castShadow = true;
                moon.receiveShadow = true;
                earth.add(moon); 
            }
            
            // Thi·∫øt l·∫≠p c√°c s·ª± ki·ªán ƒëi·ªÅu khi·ªÉn
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            document.addEventListener('click', onPlanetClick, false); 
            
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);

            // X·ª≠ l√Ω thanh tr∆∞·ª£t t·ªëc ƒë·ªô
            const speedSlider = document.getElementById('speedSlider');
            const currentSpeedSpan = document.getElementById('currentSpeed');
            speedSlider.addEventListener('input', (event) => {
                globalSpeedMultiplier = parseFloat(event.target.value);
                currentSpeedSpan.textContent = globalSpeedMultiplier.toFixed(1);
            });
            
            document.getElementById('close-help').onclick = () => {
                document.getElementById('help-overlay').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('help-overlay').style.display = 'none';
                }, 500);
            };

            createPlanetList();
            adjustTogglePosition(); // Thi·∫øt l·∫≠p tr·∫°ng th√°i UI ban ƒë·∫ßu
        }
        
        function onWindowResize() {
            if (camera && renderer && composer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight); 
            }
            adjustTogglePosition();
        }
        
        function onPlanetClick(event) {
            // Lo·∫°i tr·ª´ click v√†o UI panels
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay') || event.target.closest('#controls-toggle')) return;
            
            const clientX = event.clientX || (event.changedTouches && event.changedTouches[0].clientX);
            const clientY = event.clientY || (event.changedTouches && event.changedTouches[0].clientY);

            if (!clientX || !clientY) return;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);

            const interactableObjects = solarSystemObjects;
            const intersects = raycaster.intersectObjects(interactableObjects);
            
            if (intersects.length > 0) {
                let clickedObject = intersects[0].object;
                if (clickedObject.name === "HumanAnnotation") {
                    clickedObject = clickedObject.parent; 
                }
                focusOnObject(clickedObject);
            } else {
                focusOnObject(null);
                hideInfoPanel();
            }
        }
        
        function onMouseDown(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay') || event.target.closest('#controls-toggle')) return; 
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging || initialPinchDistance > 0) return; 
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            const rotationSpeed = 0.005;

            cameraAngle.horizontal -= deltaX * rotationSpeed;
            cameraAngle.vertical += deltaY * rotationSpeed;

            updateCameraPosition(); 
            
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseWheel(event) {
            const adaptiveZoomSpeed = cameraRadius * 0.0015; 
            cameraRadius += event.deltaY * adaptiveZoomSpeed;
            
            const minRadius = currentFocusObject ? 3 : 50;
            cameraRadius = Math.max(minRadius, Math.min(2000, cameraRadius)); 
            
            updateCameraPosition();
        }

        function getDistance(touch1, touch2) {
            const dx = touch1.clientX - touch2.clientX;
            const dy = touch1.clientY - touch2.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function onTouchStart(event) {
            if (event.target.closest('#controls') || event.target.closest('#info-panel') || event.target.closest('#help-overlay') || event.target.closest('#controls-toggle')) return; 

            if (event.touches.length === 1) {
                event.preventDefault(); 
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
                initialPinchDistance = 0;
            } else if (event.touches.length === 2) {
                event.preventDefault(); 
                isDragging = false; 
                initialPinchDistance = getDistance(event.touches[0], event.touches[1]);
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isDragging) {
                event.preventDefault(); 
                
                const deltaX = event.touches[0].clientX - previousMousePosition.x;
                const deltaY = event.touches[0].clientY - previousMousePosition.y;

                const rotationSpeed = 0.007;

                cameraAngle.horizontal -= deltaX * rotationSpeed;
                cameraAngle.vertical += deltaY * rotationSpeed;

                updateCameraPosition(); 
                
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;

            } else if (event.touches.length === 2 && initialPinchDistance > 0) {
                event.preventDefault();

                const currentPinchDistance = getDistance(event.touches[0], event.touches[1]);
                const pinchDelta = currentPinchDistance - initialPinchDistance;

                const adaptiveZoomSpeed = cameraRadius * 0.003; 

                cameraRadius -= pinchDelta * adaptiveZoomSpeed; 
                
                const minRadius = currentFocusObject ? 3 : 50;
                cameraRadius = Math.max(minRadius, Math.min(2000, cameraRadius)); 
                
                updateCameraPosition();
                
                initialPinchDistance = currentPinchDistance; 
            }
        }

        function onTouchEnd(event) {
            isDragging = false;
            if (event.touches.length < 2) { 
                initialPinchDistance = 0;
            }
        }


        /**
         * V√≤ng l·∫∑p ho·∫°t h√¨nh ch√≠nh
         */
        function animate() {
            requestAnimationFrame(animate);

            if (!composer || !scene || !camera || !clock) {
                return; 
            }
            
            const deltaTime = clock.getDelta(); 
            const effectiveDeltaTime = deltaTime * globalSpeedMultiplier;

            // 1. C·∫≠p nh·∫≠t v·ªã tr√≠ h√†nh tinh v√† c√°c v·∫≠t th·ªÉ
            for (const object of solarSystemObjects) {
                const data = object.userData;

                if (data.selfRotateSpeed) {
                    object.rotation.y += data.selfRotateSpeed * effectiveDeltaTime;
                }

                if (object.parent instanceof THREE.Group && object.parent.userData.orbitSpeed) {
                    object.parent.rotation.y += object.parent.userData.orbitSpeed * effectiveDeltaTime;
                }
            }
            
            if (earthClouds) {
                earthClouds.rotation.y += 0.05 * effectiveDeltaTime; 
            }

            if (asteroids && asteroids.userData.orbitSpeed) {
                asteroids.rotation.y += asteroids.userData.orbitSpeed * effectiveDeltaTime;
            }

            if (moon) {
                const moonSpeed = 2 * INITIAL_SPEED_FACTOR; 
                const moonRadius = 8;
                const moonGroupRotation = effectiveDeltaTime * moonSpeed;
                
                // Moon quay quanh Tr√°i ƒê·∫•t
                const moonOrbitGroup = new THREE.Group();
                moonOrbitGroup.rotation.y = moonGroupRotation;
                
                moon.position.applyAxisAngle(new THREE.Vector3(0, 1, 0), moonGroupRotation);
                moon.rotation.y += 0.1 * effectiveDeltaTime;
            }
            
            // 2. C·∫≠p nh·∫≠t m·ª•c ti√™u focus v√† Camera
            if (currentFocusObject) {
                const targetPosition = new THREE.Vector3();
                currentFocusObject.getWorldPosition(targetPosition);
                
                focusTarget.lerp(targetPosition, 0.1); 
            }

            if (!isDragging && initialPinchDistance === 0) {
                updateCameraPosition();
            }
            
            // 3. C·∫≠p nh·∫≠t th√¥ng tin kho·∫£ng c√°ch theo th·ªùi gian th·ª±c 
            if (currentFocusObject && currentFocusObject.userData.name !== 'Sun') {
                const infoDistance = document.getElementById('info-distance');
                
                const currentPos = new THREE.Vector3();
                currentFocusObject.getWorldPosition(currentPos);
                
                const distance = currentPos.length(); 
                
                if (infoDistance) {
                    infoDistance.textContent = `${distance.toFixed(2)} AU (m√¥ ph·ªèng)`;
                }
            }

            // Render
            composer.render();
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        window.onload = function () {
            try {
                init();
                animate();
            } catch (error) {
                console.error("L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o ho·∫∑c ho·∫°t h√¨nh:", error);
                document.body.innerHTML = `
                    <div class="p-8 text-center text-red-500 bg-gray-900 absolute inset-0 flex items-center justify-center flex-col">
                        <h1 class="text-3xl font-bold mb-4">L·ªói Kh·ªüi t·∫°o 3D</h1>
                        <p class="text-lg">C√≥ v·∫ª nh∆∞ tr√¨nh duy·ªát c·ªßa b·∫°n g·∫∑p s·ª± c·ªë khi ch·∫°y m√¥ ph·ªèng 3D. Vui l√≤ng ki·ªÉm tra console ho·∫∑c th·ª≠ l·∫°i.</p>
                        <p class="text-sm mt-3">Chi ti·∫øt l·ªói: ${error.message}</p>
                    </div>`;
            }
        }
    </script>
</body>
</html>
