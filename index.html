<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√¥ Ph·ªèng H·ªá M·∫∑t Tr·ªùi Ph·∫£n H·ªìi</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Th∆∞ vi·ªán Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <!-- Post-Processing dependencies for Bloom Effect (C·∫ßn thi·∫øt cho hi·ªáu ·ª©ng ph√°t s√°ng) -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/Pass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    
    <!-- C√°c Shader c·∫ßn thi·∫øt cho UnrealBloomPass -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/ConvolutionShader.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <style>
        /* ƒê·∫£m b·∫£o canvas chi·∫øm to√†n b·ªô khu v·ª±c xem v√† ƒë∆∞·ª£c cƒÉn gi·ªØa */
        body {
            margin: 0;
            overflow: hidden; 
            background-color: #0d1117;
            font-family: 'Inter', sans-serif;
            color: white;
        }
        canvas {
            display: block;
        }
        #controls {
            position: absolute;
            top: 1rem;
            left: 1rem;
            padding: 0.5rem; /* Gi·∫£m padding cho mobile */
            background: rgba(17, 24, 39, 0.7); 
            border-radius: 8px;
            z-index: 100;
            user-select: none;
            border: 1px solid rgba(55, 65, 81, 0.5);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .btn {
            padding: 0.5rem 0.5rem; /* Tinh ch·ªânh n√∫t cho mobile */
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1; /* C·ªë ƒë·ªãnh chi·ªÅu cao */
            font-size: 1.5rem; /* K√≠ch th∆∞·ªõc emoji l·ªõn h∆°n */
        }
    </style>
</head>
<body>
    <!-- B·∫£ng ƒëi·ªÅu khi·ªÉn m·ªõi -->
    <div id="controls">
        <button id="focusEarthBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white shadow-lg">
            <span role="img" aria-label="T·∫≠p trung v√†o Tr√°i ƒê·∫•t">üåé</span>
        </button>
    </div>

    <script>
        // C√°c bi·∫øn to√†n c·ª•c
        let scene = null;
        let camera = null;
        let renderer = null;
        let composer = null; 
        let clock = null;
        let solarSystemObjects = []; 
        let asteroids = null; 
        
        // C√°c bi·∫øn cho ƒëi·ªÅu khi·ªÉn camera b·∫±ng chu·ªôt/c·∫£m ·ª©ng
        let isDragging = false;
        let previousMousePosition = { x: 0, y: 0 };
        let cameraRadius = 1300; 
        let cameraAngle = { horizontal: 0, vertical: 0.4 }; 
        let focusTarget = new THREE.Vector3(0, 0, 0); 

        // D·ªØ li·ªáu h√†nh tinh (Gi·ªØ nguy√™n c√°c c·∫£i ti·∫øn tr∆∞·ªõc)
        const PLANET_DATA = [
            // Name, Size (Radius), Orbit Radius, Orbit Speed, Self Rotate Speed, Color, Emissive, Inclination, Ring Color, Axial Tilt
            { name: 'Sun', size: 15, color: 0xffffff, emissive: 0xfdd45c, orbitRadius: 0, orbitSpeed: 0, selfRotateSpeed: 0.05, inclination: 0 }, 
            { name: 'Mercury', size: 1.0, color: 0x808080, orbitRadius: 30, orbitSpeed: 1.5, selfRotateSpeed: 0.1, inclination: 7 * (Math.PI / 180) },
            { name: 'Venus', size: 2.5, color: 0xd2b48c, orbitRadius: 55, orbitSpeed: 1.0, selfRotateSpeed: 0.05, inclination: 3.4 * (Math.PI / 180) },
            { name: 'Earth', size: 3, color: 0x0088ff, orbitRadius: 90, orbitSpeed: 0.5, selfRotateSpeed: 0.5, hasMoon: true, inclination: 0.0 * (Math.PI / 180) }, 
            { name: 'Mars', size: 1.5, color: 0xa0522d, orbitRadius: 130, orbitSpeed: 0.4, selfRotateSpeed: 0.8, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Jupiter', size: 8, color: 0xd3a373, orbitRadius: 250, orbitSpeed: 0.2, selfRotateSpeed: 1.5, inclination: 1.3 * (Math.PI / 180) },
            { name: 'Saturn', size: 6, color: 0xf5deb3, orbitRadius: 400, orbitSpeed: 0.15, selfRotateSpeed: 1.2, hasRings: true, inclination: 2.5 * (Math.PI / 180), ringColor: 0x776655, axialTilt: 0.4 * Math.PI / 2 },
            { name: 'Uranus', size: 4, color: 0xafdfe4, orbitRadius: 650, orbitSpeed: 0.1, selfRotateSpeed: 0.8, hasRings: true, inclination: 0.77 * (Math.PI / 180), ringColor: 0xeeeeff, axialTilt: 98 * (Math.PI / 180) },
            { name: 'Neptune', size: 4, color: 0x00008b, orbitRadius: 900, orbitSpeed: 0.07, selfRotateSpeed: 0.7, inclination: 1.8 * (Math.PI / 180) },
            { name: 'Pluto', size: 0.5, color: 0xcccccc, orbitRadius: 1150, orbitSpeed: 0.03, selfRotateSpeed: 0.05, inclination: 17 * (Math.PI / 180) },
        ];
        
        let earth = null;
        let moon = null;
        let earthClouds = null; 


        /**
         * C·∫≠p nh·∫≠t v·ªã tr√≠ camera d·ª±a tr√™n t·ªça ƒë·ªô c·ª±c
         */
        function updateCameraPosition() {
            if (!camera) return;
            const maxVerticalAngle = Math.PI / 180 * 85;
            cameraAngle.vertical = Math.max(-maxVerticalAngle, Math.min(maxVerticalAngle, cameraAngle.vertical));

            const x = cameraRadius * Math.cos(cameraAngle.vertical) * Math.sin(cameraAngle.horizontal);
            const y = cameraRadius * Math.sin(cameraAngle.vertical);
            const z = cameraRadius * Math.cos(cameraAngle.vertical) * Math.cos(cameraAngle.horizontal);
            
            camera.position.set(x, y, z);
            camera.lookAt(focusTarget); 
        }

        /**
         * Ch·ª©c nƒÉng t·∫≠p trung camera v√†o Tr√°i ƒê·∫•t (m∆∞·ª£t m√†)
         */
        function focusOnEarth() {
            if (!earth) return;
            const earthPosition = new THREE.Vector3();
            earth.getWorldPosition(earthPosition);

            // Thi·∫øt l·∫≠p v·ªã tr√≠ m·ªõi
            focusTarget.copy(earthPosition); 
            cameraRadius = 150; 
            cameraAngle = { horizontal: 0.2, vertical: 0.3 }; 
            updateCameraPosition();
        }


        /**
         * T·∫°o n·ªÅn sao (Starfield)
         */
        function createStars() {
            const starGeometry = new THREE.BufferGeometry();
            const starVertices = []; 
            const starCount = 15000; 
            const starRange = 3000; 

            for (let i = 0; i < starCount; i++) {
                const x = THREE.MathUtils.randFloatSpread(starRange * 2);
                const y = THREE.MathUtils.randFloatSpread(starRange * 2);
                const z = THREE.MathUtils.randFloatSpread(starRange * 2);
                starVertices.push(x, y, z);
            }

            starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starVertices, 3));
            
            const starMaterial = new THREE.PointsMaterial({ color: 0xeeeeff, size: 0.8, sizeAttenuation: true });
            
            const stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }

        /**
         * T·∫°o V√†nh ƒëai Ti·ªÉu h√†nh tinh
         */
        function createAsteroidBelt() {
            const asteroidCount = 8000; 
            const beltInnerRadius = 150;
            const beltOuterRadius = 220; 
            const beltThickness = 10; 

            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const material = new THREE.PointsMaterial({ 
                color: 0x999999, 
                size: 0.1, 
                sizeAttenuation: true, 
                transparent: true,
                opacity: 0.6
            });

            for (let i = 0; i < asteroidCount; i++) {
                const radius = THREE.MathUtils.randFloat(beltInnerRadius, beltOuterRadius);
                const angle = THREE.MathUtils.randFloat(0, Math.PI * 2);
                const y = THREE.MathUtils.randFloatSpread(beltThickness);

                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                
                vertices.push(x, y, z);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            asteroids = new THREE.Points(geometry, material);
            asteroids.userData.orbitSpeed = 0.3; 
            scene.add(asteroids);
        }

        /**
         * L·∫•y v·∫≠t li·ªáu d·ª±a tr√™n lo·∫°i h√†nh tinh (PBR settings)
         */
        function getPlanetMaterial(data) {
            let roughness = 0.8;
            let metalness = 0.2;
            let color = data.color;

            const name = data.name;

            if (['Mercury', 'Mars', 'Pluto'].includes(name)) {
                roughness = 1.0;
                metalness = 0.05;
            } else if (['Venus', 'Jupiter', 'Saturn', 'Uranus', 'Neptune'].includes(name)) {
                roughness = 0.7;
                metalness = 0.1;
            } else if (name === 'Earth') {
                color = 0x1f5f9f; 
                roughness = 0.8; 
                metalness = 0.0;
            }

            return new THREE.MeshStandardMaterial({ 
                color: color, 
                roughness: roughness, 
                metalness: metalness 
            });
        }


        /**
         * Thi·∫øt l·∫≠p c·∫£nh 3D ban ƒë·∫ßu
         */
        function init() {
            console.log("Kh·ªüi t·∫°o Three.js...");

            // 1. Scene (C·∫£nh)
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a); 

            // 2. Camera (M√°y ·∫£nh)
            const aspectRatio = window.innerWidth / window.innerHeight;
            camera = new THREE.PerspectiveCamera(60, aspectRatio, 0.1, 4000); 
            updateCameraPosition(); 
            
            // 3. Renderer (B·ªô hi·ªÉn th·ªã)
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            document.body.appendChild(renderer.domElement);
            
            // 4. Composer (Hi·ªáu ·ª©ng h·∫≠u k·ª≥) - TH√äM HI·ªÜU ·ª®NG BLOOM
            composer = new THREE.EffectComposer(renderer);
            composer.addPass(new THREE.RenderPass(scene, camera));

            // Th√™m hi·ªáu ·ª©ng Bloom (Ph√°t s√°ng) 
            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // strength
                0.6, // radius
                0.05 // threshold
            );
            bloomPass.strength = 1.5; 
            composer.addPass(bloomPass);

            // 5. Clock (ƒê·ªìng h·ªì)
            clock = new THREE.Clock();

            // 6. Light (√Ånh s√°ng)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
            scene.add(ambientLight);

            // √Ånh s√°ng ƒëi·ªÉm t·ª´ M·∫∑t Tr·ªùi (Ngu·ªìn s√°ng ch√≠nh)
            const pointLight = new THREE.PointLight(0xffffff, 3.0, 3000); 
            pointLight.position.set(0, 0, 0);
            pointLight.castShadow = true; 
            pointLight.shadow.mapSize.width = 4096; 
            pointLight.shadow.mapSize.height = 4096;
            pointLight.shadow.radius = 2; 
            pointLight.shadow.camera.far = 1500; 
            scene.add(pointLight);

            // T·∫°o n·ªÅn sao v√† V√†nh ƒëai ti·ªÉu h√†nh tinh
            createStars();
            createAsteroidBelt();


            // 7. Objects (C√°c ƒë·ªëi t∆∞·ª£ng)
            
            // T·∫°o M·∫∑t Tr·ªùi
            const sunData = PLANET_DATA.find(p => p.name === 'Sun');
            const sunGeometry = new THREE.SphereGeometry(sunData.size, 64, 64);
            const sunMaterial = new THREE.MeshStandardMaterial({ 
                color: sunData.color, 
                emissive: sunData.emissive, 
                emissiveIntensity: 5.0 
            });
            const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
            sunMesh.userData = sunData;
            scene.add(sunMesh);
            solarSystemObjects.push(sunMesh); 
            
            // --- C·∫£i ti·∫øn ƒë·ªì h·ªça: Th√™m Qu·∫ßng S√°ng (Corona) cho M·∫∑t Tr·ªùi ---
            const coronaGeometry = new THREE.SphereGeometry(sunData.size * 1.5, 32, 32);
            const coronaMaterial = new THREE.MeshBasicMaterial({
                color: 0xfdd45c, // M√†u v√†ng cam
                transparent: true,
                opacity: 0.1, // R·∫•t m·ªèng
                depthWrite: false, // Kh√¥ng ghi v√†o depth buffer
                blending: THREE.AdditiveBlending, // TƒÉng c∆∞·ªùng ƒë·ªô s√°ng
            });
            const coronaMesh = new THREE.Mesh(coronaGeometry, coronaMaterial);
            sunMesh.add(coronaMesh);
            // --- K·∫øt th√∫c Corona ---


            // T·∫°o c√°c H√†nh tinh
            for (const data of PLANET_DATA) {
                if (data.name === 'Sun') continue;

                // 1. T·∫°o Group (Qu·ªπ ƒë·∫°o)
                const orbitGroup = new THREE.Group();
                if (data.inclination) {
                    orbitGroup.rotation.z = data.inclination;
                }
                scene.add(orbitGroup);

                // 2. T·∫°o H√†nh tinh (Mesh)
                const geometry = new THREE.SphereGeometry(data.size, 64, 64);
                
                const material = getPlanetMaterial(data); 
                
                const planetMesh = new THREE.Mesh(geometry, material);
                
                planetMesh.position.x = data.orbitRadius;
                planetMesh.receiveShadow = true; 
                planetMesh.castShadow = true;   

                planetMesh.userData = data;
                orbitGroup.add(planetMesh);
                orbitGroup.userData.orbitSpeed = data.orbitSpeed;
                solarSystemObjects.push(planetMesh);

                if (data.name === 'Earth') {
                    earth = planetMesh;

                    // B·∫ßu kh√≠ quy·ªÉn
                    const atmosphereGeometry = new THREE.SphereGeometry(data.size * 1.05, 64, 64); 
                    const atmosphereMaterial = new THREE.MeshStandardMaterial({
                        color: 0x9fdeff, 
                        transparent: true,
                        opacity: 0.15, 
                        depthWrite: false, 
                        side: THREE.BackSide 
                    });
                    const atmosphereMesh = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
                    planetMesh.add(atmosphereMesh); 
                    atmosphereMesh.receiveShadow = true;
                    
                    // M√¢y
                    const cloudsGeometry = new THREE.SphereGeometry(data.size * 1.005, 64, 64); 
                    const cloudsMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffffff, 
                        transparent: true,
                        opacity: 0.35, 
                        wireframe: true, 
                        wireframeLinewidth: 0.2 
                    });
                    earthClouds = new THREE.Mesh(cloudsGeometry, cloudsMaterial);
                    planetMesh.add(earthClouds);
                }
                
                // V√¢n S·ªçc & V·∫øt ƒê·ªè L·ªõn cho Sao M·ªôc (Jupiter)
                if (data.name === 'Jupiter') {
                    const radius = data.size;
                    const bandCount = 8;
                    const bandColors = [0xe8e4c0, 0xddc9a0, 0xaf9d75]; 

                    for (let i = 0; i < bandCount; i++) {
                        const bandColor = bandColors[i % bandColors.length];
                        const bandGeometry = new THREE.CylinderGeometry(radius * 1.005, radius * 1.005, radius / bandCount * 0.8, 64);
                        const bandMaterial = new THREE.MeshStandardMaterial({color: bandColor, transparent: true, opacity: 0.7, side: THREE.DoubleSide});
                        const bandMesh = new THREE.Mesh(bandGeometry, bandMaterial);
                        const yPosition = (i - (bandCount - 1) / 2) * (radius / bandCount * 1.1);
                        bandMesh.position.y = yPosition;
                        bandMesh.rotation.x = Math.PI / 2; 
                        bandMesh.name = 'JupiterBand'; 
                        planetMesh.add(bandMesh);
                    }
                    
                    // V·∫øt ƒê·ªè L·ªõn (GRS)
                    const grsRadius = radius * 0.2; 
                    const spotGeometry = new THREE.PlaneGeometry(grsRadius * 1.5, grsRadius * 0.7); 
                    const spotMaterial = new THREE.MeshStandardMaterial({ 
                        color: 0x8b0000, 
                        roughness: 0.9, 
                        metalness: 0.1, 
                        side: THREE.DoubleSide,
                        transparent: true,
                        opacity: 0.9
                    });
                    const spotMesh = new THREE.Mesh(spotGeometry, spotMaterial);
                    const grsGroup = new THREE.Group();
                    const latitude = -22 * (Math.PI / 180);
                    grsGroup.rotation.x = latitude; 
                    spotMesh.position.z = radius; 
                    spotMesh.rotation.x = Math.PI / 2; 

                    grsGroup.add(spotMesh);
                    planetMesh.add(grsGroup);
                    planetMesh.userData.grsGroup = grsGroup; 
                }

                // V√≤ng Qu·ªπ ƒê·∫°o
                const orbitLineMaterial = new THREE.LineBasicMaterial({ color: 0x666666 }); 
                const points = [];
                for (let i = 0; i <= 360; i += 5) {
                    const angle = i * Math.PI / 180;
                    points.push(new THREE.Vector3(data.orbitRadius * Math.cos(angle), 0, data.orbitRadius * Math.sin(angle)));
                }
                const orbitGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const orbitLine = new THREE.Line(orbitGeometry, orbitLineMaterial);
                orbitLine.rotation.x = Math.PI / 2; 
                orbitGroup.add(orbitLine); 

                // V√†nh ƒêai (Saturn v√† Uranus)
                if (data.hasRings) {
                    const ringGeometry = new THREE.RingGeometry(data.size * 1.5, data.size * 2.5, 128, 1, 0, Math.PI * 2);
                    
                    const pos = ringGeometry.attributes.position;
                    const v3 = new THREE.Vector3();
                    for (let i = 0; i < pos.count; i++) {
                        v3.fromBufferAttribute(pos, i);
                        pos.setY(i, v3.y * 0.005); 
                    }
                    ringGeometry.computeVertexNormals();
                    
                    const ringMaterial = new THREE.MeshStandardMaterial({ 
                        color: data.ringColor, 
                        side: THREE.DoubleSide, 
                        transparent: true,
                        opacity: 0.7, 
                        roughness: 0.9 
                    });
                    const ringMesh = new THREE.Mesh(ringGeometry, ringMaterial);
                    
                    const axialTilt = data.axialTilt || (Math.PI / 2 * 0.4); 
                    planetMesh.rotation.x = axialTilt; 
                    
                    ringMesh.rotation.x = Math.PI / 2; 
                    ringMesh.receiveShadow = true; 
                    planetMesh.add(ringMesh);
                }
            }

            // M·∫∑t TrƒÉng
            if (earth) {
                const moonOrbitRadius = 8;
                const moonGeometry = new THREE.SphereGeometry(1, 32, 32);
                const moonMaterial = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, roughness: 1.0, metalness: 0.05 });
                moon = new THREE.Mesh(moonGeometry, moonMaterial);
                moon.position.x = moonOrbitRadius;
                moon.castShadow = true;
                moon.receiveShadow = true;
                earth.add(moon); 
            }
            
            // 8. Event Listeners (B·ªô l·∫Øng nghe s·ª± ki·ªán)
            window.addEventListener('resize', onWindowResize);
            
            // B·ªô l·∫Øng nghe cho chu·ªôt
            document.addEventListener('mousedown', onMouseDown, false);
            document.addEventListener('mouseup', onMouseUp, false);
            document.addEventListener('mousemove', onMouseMove, false);
            document.addEventListener('wheel', onMouseWheel, false);
            
            // B·ªò L·∫ÆNG NGHE CHO C·∫¢M ·ª®NG (RESPONSIVE)
            document.addEventListener('touchstart', onTouchStart, false);
            document.addEventListener('touchmove', onTouchMove, false);
            document.addEventListener('touchend', onTouchEnd, false);

            document.getElementById('focusEarthBtn').addEventListener('click', focusOnEarth);

            console.log("Kh·ªüi t·∫°o ho√†n t·∫•t. S·∫µn s√†ng ch·∫°y animate.");
        }
        
        /**
         * X·ª≠ l√Ω thay ƒë·ªïi k√≠ch th∆∞·ªõc c·ª≠a s·ªï (Quan tr·ªçng cho Responsive)
         */
        function onWindowResize() {
            if (camera && renderer && composer) {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight); 
            }
        }
        
        // --- X·ª≠ l√Ω s·ª± ki·ªán chu·ªôt cho Camera ---
        
        function onMouseDown(event) {
            isDragging = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp(event) {
            isDragging = false;
        }

        function onMouseMove(event) {
            if (!isDragging) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            const rotationSpeed = 0.005;

            cameraAngle.horizontal -= deltaX * rotationSpeed;
            cameraAngle.vertical += deltaY * rotationSpeed;

            updateCameraPosition(); 
            
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseWheel(event) {
            const zoomSpeed = 0.1;
            cameraRadius += event.deltaY * zoomSpeed;
            
            cameraRadius = Math.max(50, Math.min(2000, cameraRadius)); 
            
            updateCameraPosition();
        }
        
        // --- X·ª≠ l√Ω s·ª± ki·ªán c·∫£m ·ª©ng (Touch) cho Camera ---
        
        function onTouchStart(event) {
            if (event.touches.length === 1) {
                event.preventDefault(); // NgƒÉn ch·∫∑n cu·ªôn trang
                isDragging = true;
                previousMousePosition.x = event.touches[0].clientX;
                previousMousePosition.y = event.touches[0].clientY;
            }
        }

        function onTouchMove(event) {
            if (!isDragging || event.touches.length !== 1) return;
            event.preventDefault(); // NgƒÉn ch·∫∑n cu·ªôn trang khi k√©o
            
            const deltaX = event.touches[0].clientX - previousMousePosition.x;
            const deltaY = event.touches[0].clientY - previousMousePosition.y;

            const rotationSpeed = 0.007; // TƒÉng nh·∫π t·ªëc ƒë·ªô cho c·∫£m ·ª©ng m∆∞·ª£t h∆°n

            cameraAngle.horizontal -= deltaX * rotationSpeed;
            cameraAngle.vertical += deltaY * rotationSpeed;

            updateCameraPosition(); 
            
            previousMousePosition.x = event.touches[0].clientX;
            previousMousePosition.y = event.touches[0].clientY;
        }

        function onTouchEnd(event) {
            isDragging = false;
        }


        /**
         * V√≤ng l·∫∑p ho·∫°t h√¨nh ch√≠nh
         */
        function animate() {
            requestAnimationFrame(animate);

            if (!composer || !scene || !camera || !clock) {
                return; 
            }
            
            const deltaTime = clock.getDelta(); 

            // C·∫≠p nh·∫≠t chuy·ªÉn ƒë·ªông cho t·∫•t c·∫£ v·∫≠t th·ªÉ
            for (const object of solarSystemObjects) {
                const data = object.userData;

                // T·ª± quay t·∫°i ch·ªó
                if (data.selfRotateSpeed) {
                    object.rotation.y += data.selfRotateSpeed * deltaTime;
                }

                // Quay quanh qu·ªπ ƒë·∫°o
                if (object.parent instanceof THREE.Group && object.parent.userData.orbitSpeed) {
                    object.parent.rotation.y += object.parent.userData.orbitSpeed * deltaTime;
                }
                
                // Xoay ƒë·ªôc l·∫≠p GRS c·ªßa Sao M·ªôc
                if (data.name === 'Jupiter' && data.grsGroup) {
                    data.grsGroup.rotation.y += (data.selfRotateSpeed * 0.97) * deltaTime; 
                }
            }
            
            // Xoay l·ªõp m√¢y Tr√°i ƒê·∫•t
            if (earthClouds) {
                earthClouds.rotation.y += 0.05 * deltaTime; 
            }

            // X·ª≠ l√Ω chuy·ªÉn ƒë·ªông c·ªßa V√†nh ƒëai Ti·ªÉu h√†nh tinh
            if (asteroids && asteroids.userData.orbitSpeed) {
                asteroids.rotation.y += asteroids.userData.orbitSpeed * deltaTime;
            }

            // X·ª≠ l√Ω chuy·ªÉn ƒë·ªông c·ªßa M·∫∑t TrƒÉng (quay quanh Tr√°i ƒê·∫•t)
            if (moon) {
                const elapsedTime = clock.getElapsedTime();
                const moonSpeed = 2; 
                const moonRadius = 8;
                
                moon.position.z = moonRadius * Math.sin(elapsedTime * moonSpeed);
                moon.position.x = moonRadius * Math.cos(elapsedTime * moonSpeed);
            }
            
            // Chuy·ªÉn ƒë·ªông camera m∆∞·ª£t m√† v·ªÅ m·ª•c ti√™u (khi kh√¥ng k√©o chu·ªôt)
            if (!isDragging) {
                camera.lookAt(camera.position.clone().lerp(focusTarget, 0.002 * deltaTime * 60)); 
            }

            // Render b·∫±ng Composer ƒë·ªÉ √°p d·ª•ng hi·ªáu ·ª©ng Bloom
            composer.render();
        }

        // ƒê·∫£m b·∫£o `init` ƒë∆∞·ª£c g·ªçi tr∆∞·ªõc khi `animate` b·∫Øt ƒë·∫ßu
        window.onload = function () {
            try {
                init();
                animate();
            } catch (error) {
                console.error("L·ªói trong qu√° tr√¨nh kh·ªüi t·∫°o ho·∫∑c ho·∫°t h√¨nh:", error);
            }
        }
    </script>
</body>
</html>
